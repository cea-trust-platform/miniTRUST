#Pmacro declareArr(__Scalar__,__scalar__)

#ifndef ArrOf__Scalar___included
#define ArrOf__Scalar___included

#include <Array_base.h>
#Pif("__scalar__"=="double")
#include <Double.h>
#Pendif
#Pif("__scalar__"=="int")
#include <Int.h>
#Pendif
#include <climits>

class FArrOf__Scalar__;
class V__Scalar__data;

/////////////////////////////////////////////////////////////////////////
//
// .DESCRIPTION
//  Represente un tableau d'elements de type __scalar__.
//
//  L'etat du tableau est caracterise par la valeur de p_ et de data_ :
//
//  * detache : on a alors p_==0, data_==0, size_array_==0
//     (etat obtenu par le constructeur par defaut, detach_array()
//      et resize_array(0) dans certains cas)
//
//  * normal : alors p pointe vers une structure Vdbldata, data_==p->data_
//    et size_array_ <= p->size_. A la destruction du tableau, si
//    p->ref_count_ est nul on libere la memoire.
//    data_ n'est pas nul.
//    L'espace memoire du tableau peut etre partage entre plusieurs
//    ArrOf__Scalar__ (le pointeur "p" pointe alors sur une meme structure).
//    Ce type de tableau est produit par ref_array().
//    Le dernier ArrOf__Scalar__ a utiliser une zone de memoire
//    la detruit lorsqu'il a fini (voir detach_array())
//    Si smart_resize_==0, alors on a toujours size_array_==p->size_.
//
//  * ref_data : p_==0, data_ pointe vers un tableau existant, la memoire
//    n'est pas liberee a la destruction du ArrOf__Scalar__.
//    Ces tableaux sont obtenus par appel a ref_data(...) et peuvent servir
//    pour importer un tableau fourni par une routine exterieure (C ou fortran)
//
//  Valeur initiale par defaut : voir "fill_default_value".
//  Priere de supposer desormais que les tableaux ne sont pas initialises
//  par defaut.
//
// .SECTION voir aussi
/////////////////////////////////////////////////////////////////////////

class ArrOf__Scalar__ : public Array_base
{

  Declare_instanciable_sans_constructeur_ni_destructeur(ArrOf__Scalar__);
public:
  //
  // Destructeur
  //
  ~ArrOf__Scalar__();
  //
  // Constructeurs
  //
  ArrOf__Scalar__();
  ArrOf__Scalar__(int size);
//  ArrOf__Scalar__(int size, __scalar__ initial_value);
  // Constructeur par copie : deep copy (on duplique les donnees)
  ArrOf__Scalar__(const ArrOf__Scalar__& );
  //
  // Methodes de construction tardive (on cree un tableau vide avec ArrOf__Scalar__()
  // puis on appelle ces methodes pour modifier les caracteristiques du tableau :
  // Change le nombre d'elements du tableau
  inline  void resize_array(int new_size, Array_base::Resize_Options opt = COPY_INIT);
  inline  void resize(int new_size, Array_base::Resize_Options opt = COPY_INIT);
  virtual void resize_tab(int n, Array_base::Resize_Options opt = COPY_INIT);

  // Methodes de gestion de l'allocation memoire:
  // Assigne une valeur au drapeau "smart_resize"
  // (reallocation uniquement si la taille augmente)
  void    set_smart_resize(int flag);
  // Gestion du type de memoire alouee (standard ou pool de memoire Trio-U)
  enum    Storage { STANDARD, TEMP_STORAGE };
  void    set_mem_storage(const Storage storage);
  Storage get_mem_storage() const;

  // Construction de tableaux qui pointent vers des donnees existantes
  // !!! Utiliser ref_data avec precaution (attention a size_array_)
  virtual void ref_data(__scalar__* ptr, int size);
  virtual void ref_array(ArrOf__Scalar__ &, int start = 0, int sz = -1);
  // Operateur copie
  ArrOf__Scalar__ & operator=(const ArrOf__Scalar__ &);
  // Remise du tableau dans l'etat initial (obtenu par le constructeur par defaut)
  virtual void reset();

  //
  // Methodes d'acces aux donnees et aux caracteristiques du tableau
  //
  // Remplit le tableau avec la valeur en parametre
  inline ArrOf__Scalar__ & operator=(__scalar__ valeur);
  inline       __scalar__ & operator[](int i);
  inline const __scalar__ & operator[](int i) const;
  inline       __scalar__ & operator()(int i);
  inline const __scalar__ & operator()(int i) const ;

  // Ces methodes renvoient un pointeur vers le premier element du tableau.
  const __scalar__ * addr() const;
  __scalar__ * addr();
  // Renvoie le nombre d'elements du tableau (et non la taille allouee)
  inline int size_array() const;
  // Renvoie le nombre de tableaux qui pointent vers la stucture "*p_"
  int ref_count() const;
  // Ajoute une case en fin de tableau et y stocke la "valeur"
  inline void   append_array(__scalar__ valeur);

  //
  // Operateurs divers
  //
  ArrOf__Scalar__& operator+=(const ArrOf__Scalar__&);
  ArrOf__Scalar__& operator+=(const __scalar__);
  ArrOf__Scalar__& operator-=(const ArrOf__Scalar__&);
  ArrOf__Scalar__& operator-=(const __scalar__);
  ArrOf__Scalar__& inject_array(const ArrOf__Scalar__ & source,
                                int nb_elements = -1,
                                int first_element_dest = 0,
                                int first_element_source = 0);
  ArrOf__Scalar__& copy_array(const ArrOf__Scalar__&);

  ArrOf__Scalar__ & operator=(const FArrOf__Scalar__ &);
#Pif("__scalar__"=="double")
  ArrOf__Scalar__& operator*= (const __scalar__) ;
  ArrOf__Scalar__& operator/= (const __scalar__) ;
#Pendif

  void        ordonne_array();
  void        array_trier_retirer_doublons();

protected:
  //
  // Methodes accessibles depuis les descendants de ArrOf__Scalar__
  //
  void   attach_array(const ArrOf__Scalar__& a, int start = 0, int size = -1);
  int detach_array();
  void   fill_default_value(Array_base::Resize_Options opt, int first, int nb);
  inline void resize_array_(int n, Array_base::Resize_Options opt = COPY_INIT);
private:
  // B. Mathieu 22/06/2004 : je mets ces membres "private" pour forcer
  // le passage par les accesseurs dans les classes derivees, au cas ou
  // on voudrait modifier l'implementation.

  // Zone de memoire contenant les valeurs du tableau.
  // Pointeur nul => le tableau est "detache" ou "ref_data"
  // Pointeur non nul => le tableau est "normal"
  V__Scalar__data* p_;

  // Pointeur vers le premier element du tableau=
  // Pointeur nul => le tableau est "detache".
  // Pointeur non nul => le tableau est "normal" ou "ref_data"
  //  Si p_ est non nul, data_ pointe quelque part a l'interieur de la zone allouee
  //  (en general au debut, sauf si le tableau a ete initialise
  //   avec ref() ou attach_array() avec start > 0)
  __scalar__*   data_;

  // Nombre d'elements du tableau (inferieur ou egal a memory_size_).
  // Si le tableau est "detache", alors size_array_=0
  int    size_array_;
  // Taille memoire reellement allouee pour le tableau
  // (pour le mecanisme smart_resize_). memory_size_ est nul
  // si le tableau est de type "ref_data". Sinon memory_size_
  // est egal a p_->size_.
  int    memory_size_;

  // Drapeau indiquant si on applique une strategie d'allocation
  // preventive (la memoire alouee augmente d'un facteur constant
  // si la taille devient insuffisante).
  // Si smart_resize_ == 0, alors on a toujours p_->size_ == size
  int    smart_resize_;

  // Drapeau indiquant si l'allocation memoire a lieu avec un new classique
  // ou dans le pool de memoire temporaire de Trio
  Storage   storage_type_;

  // Partie non inline de resize_array():
  void memory_resize(int new_size, Array_base::Resize_Options opt = COPY_INIT);
};

//
// Declarations des fonctions non membres de la classe ArrOf__Scalar__
//
int operator==(const ArrOf__Scalar__& x, const ArrOf__Scalar__& y) ;
int imin_array(const ArrOf__Scalar__&) ;
int imax_array(const ArrOf__Scalar__&) ;
__scalar__ min_array(const ArrOf__Scalar__&) ;
__scalar__ max_array(const ArrOf__Scalar__&) ;
__scalar__ max_abs_array(const ArrOf__Scalar__&);
__scalar__ min_abs_array(const ArrOf__Scalar__&);

#Pif("__scalar__"=="double")
__scalar__ dotproduct_array(const ArrOf__Scalar__&, const ArrOf__Scalar__&)  ;
__scalar__ norme_array(const ArrOf__Scalar__&)  ;
#Pendif

// ******************************************************************
//                   FONCTIONS MEMBRES DE ArrOf__Scalar__
// ******************************************************************

// Description :
//  Change le nombre d'elements du tableau. Cette fonction est inline
//  car elle doit etre tres rapide dans le cas ou smart_resize_==1
//  (utilisation frequente de resize_array())
//  Si smart_resize est non nul :
//   Si la nouvelle taille est inferieure ou egale a la taille
//   alouee (p->get_size()) on ne realloue pas de memoire
//   sinon, on realloue et on copie les donnees existantes.
//  Astuce pour ne pas copier les anciennes donnees:
//   resize(0); resize(n);
//  Si smart_resize est nul, on realloue une nouvelle zone memoire
//   uniquement si la nouvelle taille est differente de l'ancienne.
// Parametre: new_size
// Signification: nouvelle valeur demandee pour size_array() (doit etre >= 0)
// Parametre: opt
// Signification: quoi faire des anciennes case et des nouvelles cases (voir memory_resize())
//  Attention, pour un tableau smart_resize, l'option "INIT"
// Precondition :
//  - Si "new_size" est egal a la taille du tableau, aucune condition.
//  - Sinon,
//    * le tableau ne doit pas etre un type derive de ArrOf__Scalar__ !!!
//    * le tableau doit etre "resizable", c'est a dire:
//      soit detache, soit normal (pas de type "ref_data") avec ref_count egal a 1
inline void ArrOf__Scalar__::resize_array(int new_size, Array_base::Resize_Options opt)
{
  // Si le tableau change de taille, il doit etre du type ArrOf__Scalar__
  assert(new_size == size_array_ || get_info() == ArrOf__Scalar__::info());
  resize_array_(new_size, opt);
}

// Description: appel a ArrOf__Scalar__::resize_array()
inline void ArrOf__Scalar__::resize(int new_size, Array_base::Resize_Options opt)
{
  resize_array(new_size, opt);
}

// Description: methode protegee de changement de taille, appelable par
//  les classes derivees (idem que resize_array() mais sans condition sur le
//  type derive de l'objet)
inline void ArrOf__Scalar__::resize_array_(int new_size, Array_base::Resize_Options opt)
{
  assert(new_size >= 0);
  // Soit le tableau est detache (data_==0), soit il est normal (p_!=0)
  // S'il est normal, il ne faut pas qu'il y ait d'autre reference au tableau,
  // ou alors la taille ne doit pas changer.
  assert(new_size == size_array_ || data_ == 0 || (p_ != 0 && ref_count() == 1));
  // Le seul cas ou on n'appelle pas memory_resize est le suivant:
  //  le tableau est smart_resize
  //  ET la taille reste inferieure ou egale a la taille allouee
  //  ET on ne veut pas initialiser les nouvelles cases
  if ((opt == COPY_INIT) || (new_size > memory_size_) || (smart_resize_ == 0))
    // attention, il existe un cas ou memory_resize realloue un buffer meme si size_array_==new_size:
    // si on est passe de smart_resize=1 a smart_resize=0, on realloue juste ce qu'il faut.
    memory_resize(new_size, opt);
  size_array_ = new_size;
}

// Description:
//     x est affecte a toutes les cases
// Precondition:
// Parametre: __scalar__ x
//    Signification: la valeur a affecter a toutes les cases du tableau
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: ArrOf__Scalar__&
//    Signification: *this
//    Contraintes:
// Exception:
// Effets de bord:
// Postcondition:
inline ArrOf__Scalar__& ArrOf__Scalar__::operator=(__scalar__ x)
{
  const int n = size_array_;
  __scalar__ *data = data_;
  for (int i = 0; i < n; i++) {
    data[i] = x;
  }
  return *this;
}

// Description:
//     operateur [] retourne le ieme element du tableau
// Precondition:
// Parametre: int i
//    Signification: indice dans l'intervalle 0 <= i < size_array()
// Exception:
#Pif("__scalar__"=="double")
//    assert si la valeur sort de l'intervalle : [ -DMAXFLOAT,DMAXFLOAT ]
#Pendif
//    assert si i n'est pas dans l'intervalle
inline __scalar__& ArrOf__Scalar__::operator[](int i)
{
  assert(i >= 0 && i < size_array_);
#Pif("__scalar__"=="double")
  assert(data_[i] > -DMAXFLOAT && data_[i] < DMAXFLOAT);
#Pendif
  return data_[i];
}

// Description:
//     operateur [] retourne le ieme element du tableau
// Precondition:
// Parametre: int i
//    Signification: indice dans l'intervalle 0 <= i < size_array()
// Exception:
#Pif("__scalar__"=="double")
//    assert si la valeur sort de l'intervalle : [ -DMAXFLOAT,DMAXFLOAT ]
#Pendif
//    assert si i n'est pas dans l'intervalle
inline const __scalar__& ArrOf__Scalar__::operator[](int i) const
{
  assert(i >= 0 && i < size_array_);
#Pif("__scalar__"=="double")
  assert(data_[i] > -DMAXFLOAT && data_[i] < DMAXFLOAT);
#Pendif
  return data_[i];
}

// Description:
//     idem operator[]
inline __scalar__& ArrOf__Scalar__::operator()(int i)
{
  return operator[](i);
}

inline const __scalar__& ArrOf__Scalar__::operator()(int i) const
{
  return operator[](i);
}

// Description:
//    Renvoie la taille du tableau (nombre d'elements declares
//    a la construction ou a resize_array()).
//    C'est le nombre d'elements accessibles a operator[]
// Retour: int
inline int  ArrOf__Scalar__::size_array() const
{
  return size_array_;
}

// Description:
//  Ajoute une case en fin de tableau et y stocke la "valeur"
// Precondition:
//  Tableau doit etre de type "smart_resize" (sinon, ecroulement
//  des performances). De plus, le tableau ne doit pas etre "ref_data",
//  et il ne doit pas y avoir plus d'une reference a la zone de
//  memoire pointee (meme precondition que resize_array())
//  Le tableau doit etre de type ArrOf__Scalar__ (pas un type derive)
inline void   ArrOf__Scalar__::append_array(__scalar__ valeur)
{
  assert(smart_resize_);
  const int n = size_array_;
  resize_array(size_array_+1, COPY_NOINIT);
  data_[n] = valeur;
}

// Description:
//   Renvoie un pointeur sur le premier element du tableau.
//   Le pointeur est nul si le tableau est "detache".
//   Attention, l'adresse peut changer apres un appel
//   a resize_array(), ref_data, ref_array, ...
// Precondition:
// Retour: const __scalar__*
//   Signification: pointeur sur le premier element du tableau
inline const __scalar__* ArrOf__Scalar__::addr() const
{
  return data_;
}

// Description:
//   Renvoie un pointeur sur le premier element du tableau.
//   Le pointeur est nul si le tableau est "detache".
// Precondition:
// Retour: const __scalar__*
//    Signification: la zone memoire du tableau
inline __scalar__* ArrOf__Scalar__::addr()
{
  return data_;
}

// ArrOf__Scalar___H
#endif
#Pendmacro(declareArr)
#Pmacro implementeArr(__Scalar__,__scalar__)
#include <ArrOf__Scalar__.h>
//#include <FArrOf__Scalar__.h>
#Pif("__scalar__"=="double")
#include <math.h>
#Pendif
#ifdef SGI_
#include <bstring.h>
#endif
#include <Memoire.h>
#Pif("__scalar__"=="int")
// limits.h definit INT_MIN, SHRT_MIN, ...
#include <limits.h>
#Pendif
#include <Vect_ArrOf__Scalar__.h>
#include <Ref_ArrOf__Scalar__.h>
#include <climits>

Implemente_instanciable_sans_constructeur_ni_destructeur(ArrOf__Scalar__,"ArrOf__Scalar__",Array_base);

Implemente_vect(ArrOf__Scalar__);

Implemente_ref(ArrOf__Scalar__);

// ******************************************************************
//
//             Implementation des methodes de V__Scalar__data
//
// ******************************************************************
////////////////////////////////////////////////////////////////////
//
// .DESCRIPTION
// V__Scalar__data alloue une zone de memoire de la taille specifiee au
// constructeur, et libere la zone de memoire a la destruction.
// La memoire peut etre allouee sur le tas (avec new) ou par le
// mecanisme Memoire::add_trav___scalar__.
//
// "ref_count" compte le nombre de pointeurs qui font reference a "this".
// (permet au dernier utilisateur de l'objet de le detruire), voir
// ArrOf__Scalar__.
//
// .SECTION voir aussi
///////////////////////////////////////////////////////////////////

class V__Scalar__data {
public:
  V__Scalar__data(int size, ArrOf__Scalar__::Storage storage);
  ~V__Scalar__data();
  int          add_one_ref();
  int          suppr_one_ref();
  __scalar__ *        get_data();
  const __scalar__ *  get_data() const;
  inline int   ref_count() const;
  inline int   get_size() const;
private:
  // Le constructeur par copie et l'operateur= sont interdits.
  V__Scalar__data(const V__Scalar__data & v);
  V__Scalar__data & operator=(const V__Scalar__data & v);

  // "data" est un pointeur sur une zone de memoire de taille
  // sz * sizeof(__scalar__), allouee par le
  // constructeur et liberee par le destructeur.
  // Ce pointeur n'est jamais nul meme si size_==0
  __scalar__ * data_;
  // Compteur incremente par add_one_ref et decremente par suppr_one_ref.
  // Contient le nombre d'objets ArrOf__Scalar__ dont le membre "p" pointe
  // vers "this". On a ref_count_ >= 0.
  int ref_count_;
  // "sz" est la taille du tableau "data_" alloue
  // On a sz >= 0.
  int size_;
  // Si storage est de type TEMP_STORAGE, d_ptr_trav porte la reference
  // a la zone allouee, sinon le pointeur est nul.
  __Scalar___ptr_trav * d_ptr_trav_;
};


// Description:
//    Construit un V__Scalar__data de taille size >= 0
// Parametre: int s
//    Signification: taille du V__Scalar__data, il faut size >= 0
// Parametre: Storage storage
//    Signification: indique si la memoire doit etre allouee
//                   avec "new" ou avec "memoire.add_trav___scalar__()"
//    Valeurs par defaut: STANDARD (allocation avec "new")
// Postcondition:
//    data_ n'est jamais nul, meme si size==0
V__Scalar__data::V__Scalar__data(int size, ArrOf__Scalar__::Storage storage)
{
  int size_warning=100000000;
  assert(size >= 0);
  if (size == 0)
    storage = ArrOf__Scalar__::STANDARD;

  switch (storage) {
  case ArrOf__Scalar__::STANDARD: {
    d_ptr_trav_ = 0;
    if (size>size_warning) Cerr << "Warning: Allocating an array of " << size << " __Scalar__ ...";
#ifdef _EXCEPTION_
    // Allocation de la memoire sur le tas
    try {
      data_ = new __scalar__[size];
    }
    catch(...) {
      Cerr << "unable to allocate " << size << " __scalar__ " << finl;
      Process::exit();
    }
#else
    data_ = new __scalar__[size];
    if(!data_) {
      Cerr << "unable to allocate " << size << "__scalar__ " << finl;
      Process::exit();
    }
#endif
    if (size>size_warning) Cerr << " OK" << finl;
    break;
  }
  case ArrOf__Scalar__::TEMP_STORAGE: {
    // Allocation de la memoire sur un tas special.
    // La memoire ne sera pas rendue au systeme mais conservee pour une
    // reutilisation ulterieure.
    Memoire & memoire = Memoire::Instance();
    if (size>size_warning) Cerr << "Warning: Allocating or reusing a __Scalar__Trav of " << size << " elements ...";
#Pif("__scalar__"=="double")    d_ptr_trav_ = memoire.add_trav_double(size);#Pelse    d_ptr_trav_ = memoire.add_trav_int(size);#Pendif
    assert(d_ptr_trav_ != 0);
#Pif("__scalar__"=="double")    data_ = d_ptr_trav_->d_ptr_();#Pelse    data_ = d_ptr_trav_->i_ptr_();#Pendif
    if (size>size_warning) Cerr << " OK" << finl;
    break;

  }
  default:
    Process::exit();
  }
  ref_count_ = 1;
  size_ = size;

  assert(data_ != 0);
}

// Description:
//  Detruit la zone de memoire allouee.
// Precondition:
//  ref_count == 0 (la zone de memoire ne doit etre referencee nulle part)
V__Scalar__data::~V__Scalar__data()
{
  assert(ref_count_ == 0);
  if (d_ptr_trav_ == 0) {
    // Stockage STANDARD
    delete[] data_;
  } else {
    // Stockage TEMP_STORAGE
    d_ptr_trav_->unlock();
    d_ptr_trav_ = 0;
  }
  data_ = 0;  // paranoia: si size_==-1 c'est qu'on pointe sur un zombie
  size_ = -1; //  (pointeur vers un objet qui a ete detruit)
}

// Description: renvoie ref_count_
inline int V__Scalar__data::ref_count() const
{
  return ref_count_;
}

// Description: renvoie size_
inline int V__Scalar__data::get_size() const
{
  return size_;
}

// Description:
//     Un nouveau tableau utilise cette zone memoire :
//     incremente ref_count
// Retour: int
//    Signification: ref_count
inline int V__Scalar__data::add_one_ref()
{
  return ++ref_count_;
}

// Description:
//     Un tableau de moins utilise cette zone memoire
//     decremente ref_count
// Precondition:
//     ref_count_ > 0
// Retour: int
//    Signification: ref_count
inline int V__Scalar__data::suppr_one_ref()
{
  assert(ref_count_ > 0);
  return (--ref_count_);
}

// Description: renvoie data_
inline __scalar__ * V__Scalar__data::get_data()
{
  return data_;
}

// Description: renvoie data_
inline const __scalar__ * V__Scalar__data::get_data() const
{
  return data_;
}

// Description: Constructeur par copie. Interdit : genere une erreur !
V__Scalar__data::V__Scalar__data(const V__Scalar__data & v)
{
  Cerr << "Error in V__Scalar__data: V__Scalar__data (const V__Scalar__data & v)" << finl;
  Process::exit();
}

// Description: Operateur= interdit. Genere une erreur !
V__Scalar__data & V__Scalar__data::operator=(const V__Scalar__data & v)
{
  Cerr << "Error in V__Scalar__data::operator=(const V__Scalar__data & v)" << finl;
  Process::exit();
  return *this;
}

// ******************************************************************
//
//             Implementation des methodes de ArrOf__Scalar__
//
// ******************************************************************

// Description:
//    Ecriture du tableau sur "os" :
//    ecrit le nombre d'elements suivi des valeurs du tableau
// Precondition:
// Parametre: Sortie& os
//    Signification: le flot de sortie a utiliser
// Retour: Sortie&
//    Signification: le flot de sortie modifie
Sortie& ArrOf__Scalar__::printOn(Sortie& os) const
{
  int sz=size_array();
  os << sz << finl;
  if (sz > 0) {
    const __scalar__* v = data_;
    os.put(v,sz,sz);
  }
  return os;
}

// Description:
//    Lecture d'un tableau dans un flot d'entree
//    Lit le nombre d'elements suivi des elements eux-memes
// Precondition:
//    Le tableau doit etre "resizable" (voir precondition de resize_array_)
// Parametre: Entree& is
//    Signification: le flot d'entree a utiliser
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: Entree&
//    Signification: le flot d'entree modifie
//    Contraintes:
// Exception:
//    Si la taille lue est negative, erreur.
Entree& ArrOf__Scalar__::readOn(Entree& is)
{
  int sz;
  is >> sz;
  if (sz >= 0) {
    // Appel a la methode sans precondition sur le type derive
    // (car readOn est virtuelle, les autres proprietes seront initialisees correctement)
    resize_array_(sz);
    if (sz > 0) {
      __scalar__* v = data_;
      is.get(v,sz);
    }
  } else {
    Cerr << "Error in ArrOf__Scalar__:readOn : size = " << sz << finl;
    assert(0);
    exit();
  }
  return is;
}

// Description:
//  Destructeur : appelle detach_array()
ArrOf__Scalar__::~ArrOf__Scalar__()
{
  detach_array();
  size_array_ = -1; // Paranoia: si size_array_==-1, c'est un zombie
}

// Description:
//  Constructeur par defaut: cree un tableau "detache",
//  soit p_==0, data_==0, size_array_==0, smart_resize_==0
ArrOf__Scalar__::ArrOf__Scalar__() :
  p_(0),
  data_(0),
  size_array_(0),
  memory_size_(0),
  smart_resize_(0),
  storage_type_(STANDARD)
{
}

// Description:
//  Cree un tableau de taille n avec allocation standard (voir set_mem_storage).
//  Le tableau est rempli avec zero par defaut. Pour creer un tableau non initialise, utiliser:
//   ArrOf__Scalar__ toto;
//   toto.resize_array(n, NOCOPY_NOINIT);
// Parametre: int n
//    Signification: taille du tableau
ArrOf__Scalar__::ArrOf__Scalar__(int n) :
  p_(0),
  data_(0),
  size_array_(n),
  memory_size_(n),
  smart_resize_(0),
  storage_type_(STANDARD)
{
  if (n) {
    p_ = new V__Scalar__data(n, STANDARD);
    data_ = p_->get_data();
    fill_default_value(COPY_INIT, 0, n);
  }
}

// Description:
//     Cree un tableau de taille n
//     toutes les cases sont initialisees a x
// Precondition:
// Parametre: int n
//    Signification: taille du tableau
// Parametre: __scalar__ x
//    Signification: valeur pour initialiser le tableau
/*
ArrOf__Scalar__::ArrOf__Scalar__(int n, __scalar__ x) :
  p_(0),
  data_(0),
  size_array_(n),
  memory_size_(n),
  smart_resize_(0),
  storage_type_(STANDARD)
{
  if (n) {
    p_ = new V__Scalar__data(n, STANDARD);
    data_ = p_->get_data();
    *this = x;
  }
}
*/
// Description:
//     Constructeur par copie. On alloue une nouvelle zone de memoire
//     et on copie le contenu du tableau (il s'agit d'un "deep copy").
//     L'attribut smart_resize_ est copie aussi.
//     Si le tableau A est de taille nulle, on cree un tableau "detache",
//     sinon on cree un tableau "normal".
// Parametre: const ArrOf__Scalar__& A
//    Signification: le tableau a copier
ArrOf__Scalar__::ArrOf__Scalar__(const ArrOf__Scalar__& A): Array_base()
{
  const int size = A.size_array();
  if (size > 0) {
    // Creation d'un tableau "normal"
    storage_type_ = STANDARD;
    p_ = new V__Scalar__data(size, STANDARD);
    data_ = p_->get_data();
    size_array_ = size;
    memory_size_ = size;
    smart_resize_ = A.smart_resize_;
    inject_array(A);
  } else {
    // Creation d'un tableau "detache"
    p_ = 0;
    data_ = 0;
    size_array_ = 0;
    memory_size_ = 0;
    smart_resize_ = 0;
    storage_type_ = STANDARD;
  }
}

// Description:
//   Change le mode d'allocation memoire lors des resize
//   (voir V__Scalar__data et __Scalar___ptr_trav)
//   Exemple pour creer un tableau avec allocation temporaire:
//    DoubleTab tab; // Creation d'un tableau vide
//    tab.set_mem_storage(TEMP_STORAGE); // Changement de mode d'allocation
//    tab.resize(n); // Allocation memoire
void ArrOf__Scalar__::set_mem_storage(const Storage storage)
{
  storage_type_ = storage;
}

// Description:
//   Renvoie le mode d'allocation du tableau (qui sera utilise
//   lors du prochain resize si changement de taille).
//   (voir V__Scalar__data et __Scalar___ptr_trav)
enum ArrOf__Scalar__::Storage ArrOf__Scalar__::get_mem_storage() const
{
  return storage_type_;
}

// Description:
//   Change le mode l'allocation memoire: reallocation d'un tableau
//   a chaque changement de taille (flag = 0) ou reallocation
//   uniquement si la taille augmente et par doublement de la taille
//   du tableau (flag = 1).
void ArrOf__Scalar__::set_smart_resize(int flag)
{
  assert(flag == 0 || flag == 1);
  smart_resize_ = flag;
}

// Description:
//    Remet le tableau dans l'etat obtenu avec le constructeur par defaut
//    (libere la memoire mais conserve le mode d'allocation memoire actuel)
void ArrOf__Scalar__::reset()
{
  detach_array();
}

// Description:
//    Copie les donnees du tableau m.
//    Si "m" n'a pas la meme taille que "*this", on fait un resize_array.
//    Ensuite, on copie les valeurs de "m" dans "*this".
//    Le type de tableau (methode d'allocation) n'est pas copie.
// Precondition:
//    preconditions identiques a resize_array()
// Parametre: const ArrOf__Scalar__& m
//    Signification: la tableau a copier
// Retour:  ArrOf__Scalar__&
//    Signification: *this
ArrOf__Scalar__& ArrOf__Scalar__::operator=(const ArrOf__Scalar__& m)
{
  if (&m != this) {
    const int new_size = m.size_array();
    // On utilise la methode resize_array() qui teste le type derive de l'objet
    // (resize interdit sur un type derive)
    resize_array(new_size, NOCOPY_NOINIT);
    inject_array(m);
  }
  return *this;
}
/*
// Description:
//   Affectation d'un tableau de type FArrOf__Scalar__
//   (tableau stocke sur disque).
// Precondition:
//   Identiques a resize_array()
// Parametre: const FArrOf__Scalar__& A
//    Signification: le tableau a copier
ArrOf__Scalar__& ArrOf__Scalar__::operator=(const FArrOf__Scalar__& m)
{
  const int new_size = m.size_array();
  resize_array(new_size, NOCOPY_NOINIT);
  __scalar__ * data = data_;
  for(int i=0; i<new_size; i++)
    data[i] = m[i];

  return *this;
}
*/

// Description: appelle operator=(a)
ArrOf__Scalar__& ArrOf__Scalar__::copy_array(const ArrOf__Scalar__ & a)
{
  operator=(a);
  return *this;
}

// Description: methode virtuelle identique a resize_array(), permet de traiter
//   de facon generique les ArrOf, Vect et Tab.
//   Si l'objet est de type ArrOf__Scalar__, appel a resize_array(n)
// Prerequis: le tableau doit etre "resizable" (voir resize_array()).
//   S'il est d'un type derive (Vect ou Tab), il ne doit pas avoir de descripteur
//   parallele si la taille est effectivement modifiee.
void ArrOf__Scalar__::resize_tab(int n, Array_base::Resize_Options opt)
{
  resize_array(n, opt);
}

// Description:
//  Si besoin, alloue une nouvelle zone de memoire,
//  copie les donnees et efface l'ancienne zone de memoire.
//  Attention, on suppose que cette methode est appelee par
//  resize_array().
//  Attention: si ref_count_>1, l'appel a resize_array() est
//  autorise uniquement si la nouvelle taille est identique
//  a la precedente (auquel cas on ne fait rien)
//  Si ref_count_ == 1, l'appel est invalide si p_->data_ est
//   different de data_ (le tableau a ete construit avec ref_array()
//   avec start > 0)
// Precondition:
//  Le tableau doit etre de type "detache" ou "normal" avec
//  ref_count==1, et il faut new_size >= 0
//  On suppose que size_array contient encore le nombre d'elements
//  valides avant changement de taille.
// Parametre: new_size
//  Signification: nouvelle taille demandee pour le tableau.
// Parametre: options
//  Signification: voir ArrOf__Scalar__::Resize_Options
// Postcondition:
//  p_ et data_ sont mis a jour, mais pas size_array_ !!!
//  (on suppose que c'est fait dans resize_array()).
//  Si la nouvelle taille est nulle, on detache le tableau.
void  ArrOf__Scalar__::memory_resize(int new_size, Array_base::Resize_Options opt)
{
  assert(new_size >= 0);

  // Si new_size==size_array_, on ne fait rien, c'est toujours autorise
  if (new_size == size_array_)
    return;

  // Sinon, il faut que le resize soit autorise, c'est a dire
  //  - soit le tableau est detache
  //  - soit le tableau est normal et il n'y a pas d'autre reference au tableau
  assert((data_ == 0) || ((p_ != 0) && (p_->get_data() == data_) && (ref_count() == 1)));

  // Occupation memoire de l'ancien tableau:
  int old_mem_size = memory_size_;
  assert((!p_) || (p_->get_size() == memory_size_));
  assert(memory_size_ >= size_array_);

  // Occupation memoire du nouveau tableau :
  // Si smart_resize, on prend au moins deux fois la taille
  // precedente, ou new_size
  int new_mem_size = new_size;
  if (smart_resize_) {
    if (new_size <= old_mem_size)
      new_mem_size = old_mem_size;
    else if (new_size < old_mem_size * 2)
      new_mem_size = old_mem_size * 2;
    else if (new_size > old_mem_size && old_mem_size > INT_MAX / 2)
      new_mem_size = INT_MAX;
  }

  if (new_mem_size != old_mem_size) {
    // detach_array() efface le contenu de size_array_. On le met de cote:
    const int old_size_array = size_array_;
    if (new_mem_size == 0) {
      // La nouvelle taille est nulle, on cree un tableau "detache"
      detach_array();
    } else {
      // Allocation d'une nouvelle zone
      V__Scalar__data * new_p = new V__Scalar__data(new_mem_size, storage_type_);
      __scalar__ * new_data = new_p->get_data();
      // Raccourci si le tableau etait "detache", inutile de copier
      // les anciennes donnees. On copie si COPY_OLD est demande
      int copy_size = 0;
      if (data_ != 0) {
        // Calcul du nombre d'elements a copier vers la nouvelle
        // zone de memoire : c'est le min de l'ancienne et de
        // la nouvelle taille.
        if (opt != NOCOPY_NOINIT) {
          copy_size = size_array_;
          if (new_size < copy_size)
            copy_size = new_size;
          // Copie des valeurs dans le nouveau tableau
          for (int i = 0; i < copy_size; i++)
            new_data[i] = data_[i];
        }
        // Destruction de l'ancienne zone (si plus aucune reference)
        detach_array();
      }
      // On attache la nouvelle zone de memoire
      p_ = new_p;
      data_ = new_data;
      memory_size_ = new_mem_size;
      // Initialisation des cases supplementaires avec une valeur par defaut
      fill_default_value(opt, copy_size, new_mem_size - copy_size);
      // Restaure l'ancienne valeur de size_array_
      size_array_ = old_size_array;
    }
  } else {
    // Pas de reallocation, initialisation si besoin
    if (opt == COPY_INIT && new_size > size_array_) {
      fill_default_value(opt, size_array_, new_size - size_array_);
    }
  }
}

// Description:
//  Remplit "nb" cases consecutives du tableau a partir de la case "first"
//  avec une valeur par defaut.
//  Cette fonction est appelee lors d'un resize pour initialiser les
//  cases nouvellement creees.
//  Le comportement depend actuellement du type de tableau :
//  * Tableau de type "smart_resize":
//    * en mode debug (macro NDEBUG non definie) le tableau est initialise
//      avec une valeur invalide.
//    * en optimise, le tableau n'est pas initialise
//  * Tableau normal :
//    Le tableau est initialise avec la valeur 0. Ce comportement est choisi
//    pour des raisons de compatibilite avec l'implementation precedente.
//    Cette specification pourrait etre modifiee prochainement pour des raisons
//    de performances (pour ne pas avoir a initialiser inutilement les tableaux).
//    DONC: il faut supposer desormais que les nouvelles cases ne sont pas
//    initialisees lors d'un resize.
// Parametre: first
//  Signification: premiere case a initialiser.
//  Contrainte:    (nb==0) ou (0 <= first < memory_size_)
// Parametre: nb
//  Signification: nombre de cases a initialiser.
//  Contrainte:    (nb==0) ou (0 < nb <= memory_size_ - first)
void  ArrOf__Scalar__::fill_default_value(Array_base::Resize_Options opt, int first, int nb)
{
  assert((nb == 0) || (first >= 0 && first < memory_size_));
  assert((nb == 0) || (nb > 0 && nb <= memory_size_ - first));
  __scalar__ * data = data_;
  assert(data!=0 || nb==0);
  data += first;
  if (opt != COPY_INIT) {
    // On initialise uniquement en mode debug
#ifndef NDEBUG
#Pif("__scalar__"=="int")
    static const int INT_INVALIDE = INT_MIN;
    for (int i = 0; i < nb; i++)
      data[i] = INT_INVALIDE;
#Pendif
#Pif("__scalar__"=="double")
    // B.M. L'utilisation de NAN n'est pas possible car elle provoque une erreur
    // dans double & operator[] a cause de assert(...DMAXFLOAT). Du coup il est
    // impossible de mettre une valeur dans le tableau autrement qu'avec append_array()
#if 0
    // Ceci represente un NAN. N'importe quelle operation avec ca fait encore un NAN.
    // Si c'est pas portable, on peut remplacer par DMAX_FLOAT sur les autres machines.
    // Attention, il faut long long car sinon warning sur gcc 4.1 et i686
    static const unsigned long long VALEUR_INVALIDE =
      0x7ff7ffffffffffffULL;
    /* static const double VALEUR_INVALIDE = DMAXFLOAT;    */

    // On utilise "memcpy" et non "=" car "=" peut provoquer une exception
    // si la copie passe par le fpu.
    for (int i = 0; i < nb; i++)
      memcpy(data + i, & VALEUR_INVALIDE, sizeof(double));
#else
    // Alternative acceptable... ?
    for (int i = 0; i < nb; i++)
      data[i] = DMAXFLOAT*0.999;
#endif
#Pendif
#endif
  } else {
    // Comportement pour les tableaux normaux : compatibilite avec la
    // version precedente : on initialise avec 0.
    for (int i = 0; i < nb; i++)
      data[i] = (__scalar__) 0;
  }
}

// ****************************************************************
//
//         Fonctions non membres de la classe ArrOf__Scalar__
//
// ****************************************************************

// Description:
//  Renvoie 1 si les tableaux "v" et "a" sont de la meme taille
//  et contiennent les memes valeurs au sens strict, sinon renvoie 0.
//  Le test est !(v[i]!=a[i])
int operator==(const ArrOf__Scalar__& v, const ArrOf__Scalar__& a)
{
  const int n = v.size_array();
  const int na = a.size_array();
  int resu = 1;
  if (n != na) {
    resu = 0;
  } else {
    const __scalar__* vv = v.addr();
    const __scalar__* av = a.addr();
    int i;
    for (i = 0; i < n; i++) {
      if (av[i] != vv[i]) {
        resu = 0;
        break;
      }
    }
  }
  return resu;
}

// Description:
//    Retourne l'indice du min ou -1 si le tableau est vide
// Precondition:
// Parametre: const ArrOf__Scalar__& dx
//    Signification: tableau a utiliser
// Retour: int
//    Signification: indice du min
int imin_array(const ArrOf__Scalar__& dx){
  int indice_min = -1;
  const int size = dx.size_array();
  if (size > 0) {
    indice_min = 0;
    __scalar__ valeur_min = dx[0];
    for(int i = 1; i < size; i++) {
      const __scalar__ val = dx[i];
      if(val < valeur_min) {
        indice_min = i;
        valeur_min = val;
      }
    }
  }
  return indice_min;
}

// Description:
//    Retourne l'indice du max ou -1 si le tableau est vide
// Precondition:
// Parametre: const ArrOf__Scalar__& dx
//    Signification: tableau a utiliser
// Retour: int
//    Signification: indice du max
int imax_array(const ArrOf__Scalar__& dx){
  int indice_max = -1;
  const int size = dx.size_array();
  if (size > 0) {
    indice_max = 0;
    __scalar__ valeur_max = dx[0];
    for(int i = 1; i < size; i++) {
      const __scalar__ val = dx[i];
      if(val > valeur_max) {
        indice_max = i;
        valeur_max = val;
      }
    }
  }
  return indice_max;
}

// Description:
//    Retourne la valeur minimale
// Precondition:
//    Le tableau doit contenir au moins une valeur
// Parametre: const ArrOf__Scalar__& dx
//    Signification: tableau a utiliser
// Retour: __scalar__
//    Signification: valeur du min
__scalar__ min_array(const ArrOf__Scalar__& dx)
{
  const int size = dx.size_array();
  assert(size > 0);
  __scalar__ valeur_min = dx[0];
  for(int i = 1; i < size; i++) {
    const __scalar__ val = dx[i];
    if (val < valeur_min)
      valeur_min = val;
  }
  return valeur_min;
}

// Description:
//    Retourne la valeur maximale
// Precondition:
//    Le tableau doit contenir au moins une valeur
// Parametre: const ArrOf__Scalar__& dx
//    Signification: tableau a utiliser
// Retour: __scalar__
//    Signification: valeur du max
__scalar__ max_array(const ArrOf__Scalar__& dx)
{
  const int size = dx.size_array();
  assert(size > 0);
  __scalar__ valeur_max = dx[0];
  for(int i = 1; i < size; i++) {
    const __scalar__ val = dx[i];
    if (val > valeur_max)
      valeur_max = val;
  }
  return valeur_max;
}

static inline __scalar__ scalar_abs(__scalar__ x)
{
#Pif("__scalar__"=="double")
  return dabs(x);
#Pendif
#Pif("__scalar__"=="int")
  return abs(x);
#Pendif
}

// Description:
//    Retourne le max des abs(i)
// Precondition:
//    Le tableau doit contenir au moins une valeur
// Parametre: const ArrOf__Scalar__& dx
//    Signification: tableau a utiliser
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: __scalar__
//    Signification: valeur du max des valeurs absolues
//    Contraintes:
// Exception:
// Effets de bord:
// Postcondition:
__scalar__ max_abs_array(const ArrOf__Scalar__& dx)
{
  const int size = dx.size_array();
  assert(size > 0);
  __scalar__ valeur_max = scalar_abs(dx[0]);
  for(int i = 1; i < size; i++) {
    const __scalar__ val = scalar_abs(dx[i]);
    if (val > valeur_max)
      valeur_max = val;
  }
  return valeur_max;
}

// Description:
//    Retourne le min des abs(i)
// Precondition:
//    Le tableau doit contenir au moins une valeur
// Parametre: const ArrOf__Scalar__& dx
//    Signification: tableau a utiliser
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: __scalar__
//    Signification: valeur du min des valeurs absolues
//    Contraintes:
// Exception:
// Effets de bord:
// Postcondition:
__scalar__ min_abs_array(const ArrOf__Scalar__& dx)
{
  const int size = dx.size_array();
  assert(size > 0);
  __scalar__ v = scalar_abs(dx[0]);
  for(int i = 1; i < size; i++) {
    const __scalar__ val = scalar_abs(dx[i]);
    if (val < v)
      v = val;
  }
  return v;
}

// Description:
//   Fonction de comparaison utilisee pour trier le tableau
//   dans ArrOf__Scalar__::trier(). Voir man qsort
static True_int  fonction_compare_arrof__scalar___ordonner(const void * data1, const void * data2)
{
  const __scalar__ x = *(const __scalar__*)data1;
  const __scalar__ y = *(const __scalar__*)data2;
#Pif("__scalar__"=="double")
  if (x < y)
    return -1;
  else if (x > y)
    return 1;
  else
    return 0;
#Pendif
#Pif("__scalar__"=="int")
#ifndef INT_is_64_
  return x - y;
#else
  if (x < y)
    return -1;
  else if (x > y)
    return 1;
  else
    return 0;
#endif
#Pendif
}

// Description:
//   Tri des valeurs du tableau dans l'ordre croissant.
//   La fonction utilisee est qsort de stdlib (elle est en n*log(n)).
void ArrOf__Scalar__::ordonne_array()
{
  const int size = size_array_;
  if (size > 1) {
    __scalar__ * data = data_;
    qsort(data, size, sizeof(__scalar__),
          fonction_compare_arrof__scalar___ordonner);
  }
}

// Description:
//   Tri des valeurs du tableau dans l'ordre croissant et suppresion des doublons
//   La fonction utilisee est qsort de stdlib (elle est en n*log(n)).
void ArrOf__Scalar__::array_trier_retirer_doublons()
{
  const int size_ = size_array_;
  if (size_ <= 0)
    return;
  // Tri dans l'ordre croissant
  ordonne_array();
  // Retire les doublons (codage optimise en pointeurs)
  __scalar__ last_value = *data_;
  __scalar__ *src = data_ + 1;
  __scalar__ *dest = data_ + 1;
  for (int i = size_ - 1; i != 0; i--) {
    __scalar__ x = *(src++);
    if (x != last_value) {
      *(dest++) = x;
      last_value = x;
    }
  }
  int new_size_ = dest - data_;
  resize_array(new_size_);
}

// Description:
//    Fait pointer le tableau vers les memes donnees qu'un tableau
//    existant. Le tableau sera du meme type que le tableau m ("detache",
//    "normal"). Le tableau m ne doit pas etre de type "ref_data"
//    Attention, le tableau source et *this sont ensuite figes (resize_array()
//    interdit).
//   Attention: methode virtuelle: dans les classes derivee, cette methode
//    initialise les structures pour creer un tableau sequentiel.
// Parametre: const ArrOf__Scalar__& m
//    Signification: le tableau a referencer (pas de type "ref_data"
//                   et different de *this !!!)
// Retour: ArrOf__Scalar__&
//    Signification: *this
//    Contraintes:
// Exception:
// Effets de bord:
// Postcondition:
void ArrOf__Scalar__::ref_array(ArrOf__Scalar__& m, int start, int size)
{
  assert(&m != this);
  // La condition 'm n'est pas de type "ref_data"' est necessaire pour
  // attach_array().
  detach_array();
  attach_array(m, start, size);
}

// Description:
//    Fait pointer le tableau vers la zone de memoire "data_".
//    On detache la zone de memoire existante. Le tableau devient
//    de type "ref_data". Attention : ptr doit etre non nul.
//    La taille est initialisee avec size.
//   Attention: methode virtuelle: dans les classes derivee, cette methode
//    initialise les structures pour creer un tableau sequentiel.
//    Pour faire une ref sur un tableau parallele utiliser __Scalar__Vect::ref()
// Parametre: __scalar__*
//    Signification: le tableau a recuperer. Si pointeur nul alors size
//                   doit etre nulle aussi et le tableau reste detache
// Parametre: int size
//    Signification: le nombre d'elements du tableau.
// Retour: ArrOf__Scalar__&
//    Signification: *this
void ArrOf__Scalar__::ref_data(__scalar__* ptr, int size)
{
  assert(ptr != 0 || size == 0);
  assert(size >= 0);
  detach_array();
  data_ = ptr;
  size_array_ = size;
  memory_size_ = size; // Pour passer les tests si on resize a la meme taille
}

// Description:
//  Amene le tableau dans l'etat "detache". C'est a dire:
//  Si le tableau est "detache" :
//   * ne rien faire
//  Si le tableau est "normal" :
//   * decremente le nombre de references a *p
//   * detruit *p si p->ref_count==0
//   * annule p_, data_ et size_array_
//  Si le tableau est "ref_data" :
//   * annule data_ et size_array_
// Retour: int
//    Signification: 1 si les donnees du tableau ont ete supprimees
// Precondition:
// Postcondition:
//  On a p_==0, data_==0 et size_array_==0, memory_size_ = 0
//  L'attribut smart_resize_ est conserve.
int ArrOf__Scalar__::detach_array()
{
  int retour = 0;
  if (p_) {
    // Le tableau est de type "normal"
    // Si la zone de memoire n'est plus utilisee par personne,
    // on la detruit.
    if ((p_->suppr_one_ref()) == 0) {
      delete p_;
      retour = 1;
    }
    p_ = 0;
  }
  data_ = 0;
  size_array_ = 0;
  memory_size_ = 0;
  return retour;
}

// Description:
//    Amene le tableau dans l'etat "normal", "detache" ou "ref_array"
//    en associant une sous-zone de memoire du tableau m, definie par start et size
//    Si size < 0, on prend le tableau m jusqu'a la fin.
// Precondition:
//    Le tableau doit etre "detache"
// Parametre: const ArrOf__Scalar__& m
//    Signification: tableau a utiliser
//                   le tableau doit etre different de *this !!!
// Retour:
//    Signification:
//    Contraintes:
// Exception:
// Effets de bord:
// Postcondition:
//    Si m est detache, le tableau reste detache,
//    si m est "ref_array", le tableau devient "ref_array",
//    sinon le tableau est "normal", avec ref_count > 1
//    Si m est de taille nulle, le tableau reste detache + Warning dans fichier .log
void ArrOf__Scalar__::attach_array(const ArrOf__Scalar__& m, int start, int size)
{
  // Le tableau doit etre detache
  assert(data_ == 0 && p_ == 0);
  // Le tableau doit etre different de *this
  assert(&m != this);
  if (size < 0)
    size = m.size_array_ - start;
  assert(start >= 0 && size >=0 && start + size <= m.size_array_);
  if (m.size_array() > 0) {
    p_ = m.p_;
    if (p_)
      p_->add_one_ref();
    data_ = m.data_ + start;
    size_array_ = size;
    memory_size_ = m.memory_size_ - start;
    smart_resize_ = m.smart_resize_;
  } else {
    // Cas particulier ou on attache un tableau de taille nulle:
    //  en theorie, c'est pareil qu'un tableau de taille non nulle, MAIS
    //  dans les operateurs (ex:Op_Dift_VDF_Face_Axi), une ref est construite
    //  avant que le tableau ne prenne sa taille definitive. Donc, pour ne pas
    //  empecher le resize, il ne faut pas attacher le tableau s'il n'a pas
    //  encore la bonne taille. Solution propre: reecrire les operateurs pour
    //  qu'ils ne prennent pas une ref avant que le tableau ne soit valide
    //  et faire p_ = m.p_ dans tous les cas.
    // Process::Journal() << "Warning ArrOf__Scalar__::attach_array(m), m.size_array()==0, on n attache pas le tableau" << finl;
  }
}

// Description:
//    Copie les elements source[first_element_source + i]
//    dans les elements  (*this)[first_element_dest + i] pour 0 <= i < nb_elements
//    Les autres elements de (*this) sont inchanges.
// Precondition:
// Parametre:       const ArrOf__Scalar__& m
//  Signification:   le tableau a utiliser, doit etre different de *this !
// Parametre:       int nb_elements
//  Signification:   nombre d'elements a copier, nb_elements >= -1.
//                   Si nb_elements==-1, on copie tout le tableau m.
//  Valeurs par defaut: -1
// Parametre:       int first_element_dest
//  Valeurs par defaut: 0
// Parametre:       int first_element_source
//  Valeurs par defaut: 0
// Retour: ArrOf__Scalar__&
//    Signification: *this
//    Contraintes:
// Exception:
//    Sort en erreur si la taille du tableau m est plus grande que la
//    taille de tableau this.
// Effets de bord:
// Postcondition:
ArrOf__Scalar__& ArrOf__Scalar__::inject_array(const ArrOf__Scalar__& source,
                                               int nb_elements,
                                               int first_element_dest,
                                               int first_element_source)
{
  assert(&source != this);
  assert(nb_elements >= -1);
  assert(first_element_dest >= 0);
  assert(first_element_source >= 0);

  if (nb_elements < 0)
    nb_elements = source.size_array();

  assert(first_element_source + nb_elements <= source.size_array());
  assert(first_element_dest + nb_elements <= size_array());

  if (nb_elements > 0) {
    __scalar__ * addr_dest = data_ + first_element_dest;
    const __scalar__ * addr_source = source.addr() + first_element_source;
    // PL: On utilise le memcpy car c'est VRAIMENT plus rapide (10% +vite sur RNR_G20)
    memcpy(addr_dest , addr_source, nb_elements * sizeof(__scalar__));
    /*
      int i;
      for (i = 0; i < nb_elements; i++) {
      addr_dest[i] = addr_source[i];
      } */
  }
  return *this;
}

// Description:
//    Retourne le nombre de references des donnees du tableau
//    si le tableau est "normal", -1 s'il est "detache" ou "ref_data"
// Retour: int
//    Signification: ref_count_
int ArrOf__Scalar__::ref_count() const
{
  if (p_)
    return p_->ref_count();
  else
    return -1;
}

// Description:
//    Addition case a case sur toutes les cases du tableau
// Precondition:
//    la taille de y doit etre au moins egale a la taille de this
// Parametre: const ArrOf__Scalar__& y
//    Signification: tableau a ajouter
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: ArrOf__Scalar__&
//    Signification: *this
//    Contraintes:
// Exception:
// Effets de bord:
// Postcondition:
ArrOf__Scalar__& ArrOf__Scalar__::operator+=(const ArrOf__Scalar__& y)
{
  assert(size_array()==y.size_array());
  __scalar__* dx = data_;
  const __scalar__* dy = y.data_;
  const int n = size_array();
  for (int i=0; i<n; i++)
    dx[i] += dy[i];
  return *this;
}

// Description:
//     ajoute la meme valeur a toutes les cases du tableau
// Precondition:
// Parametre: const __scalar__ dy
//    Signification: valeur a ajouter
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: ArrOf__Scalar__
//    Signification: *this
//    Contraintes:
// Exception:
// Effets de bord:
// Postcondition:
ArrOf__Scalar__& ArrOf__Scalar__::operator+=(const __scalar__ dy)
{
  __scalar__ * data = data_;
  const int n = size_array();
  for(int i=0; i < n; i++)
    data[i] += dy;
  return *this;
}
// Description:
//    Soustraction case a case sur toutes les cases du tableau
// Parametre: const ArrOf__Scalar__& y
//    Signification: tableau de meme taille que *this
// Retour: ArrOf__Scalar__&
//    Signification: *this
ArrOf__Scalar__& ArrOf__Scalar__::operator-=(const ArrOf__Scalar__& y)
{
  const int size = size_array();
  assert(size == y.size_array());
  __scalar__ * data = data_;
  const __scalar__ * data_y = y.data_;
  for (int i=0; i < size; i++)
    data[i] -= data_y[i];
  return *this;
}


// Description:
//     soustrait la meme valeur a toutes les cases
// Retour: ArrOf__Scalar__ &
//    Signification: *this
ArrOf__Scalar__& ArrOf__Scalar__::operator-=(const __scalar__ dy)
{
  __scalar__ * data = data_;
  const int n = size_array();
  for(int i=0; i < n; i++)
    data[i] -= dy;
  return *this;
}

#Pif("__scalar__"=="double")

// Description:
//     muliplie toutes les cases par dy
// Retour: ArrOf__Scalar__ &
//    Signification: *this
ArrOf__Scalar__& ArrOf__Scalar__::operator*= (const __scalar__ dy)
{
  __scalar__ * data = data_;
  const int n = size_array();
  for(int i=0; i < n; i++)
    data[i] *= dy;
  return *this;
}


// Description:
//     divise toutes les cases par dy
// Retour: ArrOf__Scalar__ &
//    Signification: *this
ArrOf__Scalar__& ArrOf__Scalar__::operator/= (const __scalar__ dy)
{
  const __scalar__ i_dy = 1. / dy;
  operator*=(i_dy);
  return *this;
}

// Description:
//    Produit scalaire de deux "array".
//    (dotproduct_array remplace operator* car le nom indique clairement
//     que l'on fait un produit scalaire non distribue)
// Precondition:
// Parametre: const ArrOf__Scalar__& dx
//    Signification: premier tableau
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Parametre: const ArrOf__Scalar__& dy
//    Signification: second tableau (obligatoirement de meme taille)
//    Valeurs par defaut:
//    Contraintes:
//    Acces:
// Retour: __scalar__
//    Signification: produit scalaire
//    Contraintes:
__scalar__ dotproduct_array (const ArrOf__Scalar__& dx, const ArrOf__Scalar__& dy)
{
  // const int size = dx.size_array();
  // assert(size == dy.size_array());
  // __scalar__ resultat = 0.;
  // if (size > 0) {
  //   integer n = size;
  //   integer incx = 1;
  //   resultat = F77NAME(DDOT)(&n, dx.addr(), &incx, dy.addr(), &incx);
  // }
  // return resultat;
  throw;
  return 0;
}

// Description:
//   Calcul de la norme du vecteur dx (fonction blas DNRM2,
//   soit racine carree(somme des dx[i]*dx[i]).
__scalar__ norme_array(const ArrOf__Scalar__& dx)
{
  // integer n = dx.size_array();
  // __scalar__ resultat = 0.;
  // if (n > 0) {
  //   integer incx = 1;
  //   resultat = F77NAME(DNRM2)(&n, &dx(0), &incx);
  // }
  // return resultat;
  throw;
  return 0;
}
#Pendif
#Pendmacro(implementeArr)
