/****************************************************************************
* Copyright (c) 2021, CEA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*****************************************************************************/
//////////////////////////////////////////////////////////////////////////////
//
// File:        IntVect.cpp
// Directory:   $TRUST_ROOT/src/Kernel/Math
// Version:     /main/v157_front_tracking/v157_ft_gbois/1
//
//////////////////////////////////////////////////////////////////////////////
//
// WARNING: DO NOT EDIT THIS FILE! Only edit the template file IntVect.cpp.P
//
//
#include <IntVect.h>
#ifdef SGI_
#include <bstring.h>
#endif
#include <MD_Vector_base.h>
#include <MD_Vector_tools.h>
#include <limits.h>
#include <communications.h>

// Pour la relecture des anciens fichiers de reprise, voir IntVect::lit()
#include <DescStructure.h>

Implemente_instanciable_sans_constructeur_ni_destructeur(IntVect, "IntVect", ArrOfInt);

// Description: Ecriture d'un vecteur sequentiel (sans descripteur parallele)
//  Pour l'instant: erreur si presence d'un md_vector_ (sinon quoi faire ?)
//  Pour les vecteurs paralleles, utiliser une methode de sauvegarde/reprise
Sortie& IntVect::printOn(Sortie& os) const
{
  if (nproc() > 1 && md_vector_.non_nul())
    {
      Cerr << "Error in IntVect::printOn: try to print a parallel vector" << finl;
      exit();
    }
  ArrOfInt::printOn(os);
  return os;
}

// Description: Lecture d'un vecteur sequentiel (comme un ArrOfInt)
//  Attention: appel invalide si le vecteur a un MD_Vector non nul.
//  (pour les vecteurs paralleles, utiliser une methode de sauvegarde/reprise)
Entree& IntVect::readOn(Entree& is)
{
  if (md_vector_.non_nul())
    {
      // Que veut-on faire si on lit dans un vecteur ayant deja une structure parallele ?
      Cerr << "Error in IntVect::readOn: vector has a parallel structure" << finl;
      exit();
    }
  ArrOfInt::readOn(is);
  size_reelle_ = size_array();
  line_size_ = 1;
  return is;
}

// Description: construction d'un vecteur de taille n.
//  Les elements du vecteur sont initialises a zero par defaut.
//  Pour ne pas initialiser les valeurs, utiliser ceci:
//   IntVect toto;
//   toto.resize(n, NOCOPY_NOINIT);
IntVect::IntVect(int n) :
  ArrOfInt(n),
  size_reelle_(n),
  line_size_(1)
{
}
/*
// Description: construction d'un vecteur de taille n.
//  Les elements du vecteur sont initialises avec la valeur x.
IntVect::IntVect(int n, int x) :
  ArrOfInt(n, x),
  size_reelle_(n),
  line_size_(1)
{
}
*/
// Description: Constructeur par copie. Il s'agit d'un "deep copy"
//   voir ArrOfInt::ArrOfInt(const ArrOfInt &)
//  Remarque: il n'y a pas de constructeur par copie a partir de ArrOfInt
//   Ceci est volontaire, sinon on risque de grosses pertes de performances
//   par creation implicite d'objets, difficile a trouver.
//   (exemple: appel d'une methode toto(const IntVect &) avec un ArrOfInt
//    produit une copie du tableau !)
//  Utiliser copy() pour copier un ArrOfInt dans un IntVect
IntVect::IntVect(const IntVect& v) :
  ArrOfInt(v),
  md_vector_(v.md_vector_),
  size_reelle_(v.size_reelle_),
  line_size_(v.line_size_)
{
}

// Description: met l'objet dans l'etat obtenu par le constructeur par defaut.
//  (voir ArrOfInt::reset())
void IntVect::reset()
{
  md_vector_.detach();
  line_size_ = 1;
  size_reelle_ = 0;
  ArrOfInt::reset();
}

// Description: detach the vector.
void IntVect::detach_vect()
{
  md_vector_.detach();
}

// Description: detache le tableau et l'attache a v (sauf si v==*this, ne fait rien)
//  Fait pointer le tableau sur la meme zone de memoire que v et copie le MD_Vector
//  (utilise ArrOfInt::attach_array())
//  Attention, il devient alors interdit de resizer le tableau v ainsi que *this
//  Methode virtuelle reimplementee dans IntTab
// Precondition:
//  L'objet ne doit pas etre un sous-type de IntVect (sinon mauvaise initialisation
//  des dimensions.
void IntVect::ref(const IntVect& v)
{
  if (&v != this)
    {
      detach_array();
      attach_array(v);
      md_vector_ = v.md_vector_;
      size_reelle_ = v.size_reelle_;
      line_size_ = v.line_size_;
    }
}

// Description: copie la structure et les valeurs du tableau v dans *this avec ArrOfInt::operator=()
//  (attention, si le tableau est de type ref_data ou ref, restrictions et cas particuliers !!!)
//  Attention: si on ne veut pas copier les structures paralleles, utiliser inject_array()
// Precondition: si le tableau *this doit etre resize, il doit etre de type IntVect
//  (et pas d'un type derive !)
//  Si le tableau *this a deja une structure parallele, l'appel n'est autorise que les md_vector
//  sont deja identiques, sinon il faut d'abord faire un reset() du tableau (pour copier la structure),
//  ou utiliser inject_array() (pour ne pas copier la structure).
//  (ceci pour eviter d'ecraser accidentellement une structure parallele alors qu'on ne veut
//   que copier les valeurs).
IntVect& IntVect::operator=(const IntVect& v)
{
  copy(v);
  return *this;
}

// Description: copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v.
//  Attention, v doit vraiment etre de type ArrOfInt, pas d'un type derive
//  (sinon ambiguite: faut-il copier ou pas le MD_Vector ?)
// Precondition: Le vecteur ne doit pas avoir de structure de tableau distribue
//  et il doit vraiment etre de type IntVect.
void IntVect::copy(const ArrOfInt& v, Array_base::Resize_Options opt)
{
  assert(get_info() == IntVect::info());
  assert(v.get_info() == ArrOfInt::info());
  assert(!md_vector_.non_nul());
  resize(v.size_array(), opt);
  if (opt != NOCOPY_NOINIT)
    inject_array(v);
}

// Description: copie de la structure du vecteur v et des valeurs si opt==COPY_INIT.
// Precondition: idem que operator=(const IntVect &)
void IntVect::copy(const IntVect& v, Array_base::Resize_Options opt)
{
  if (&v != this)
    {
      // Interdiction de resizer si l'objet est d'un type derive de IntVect
      // (sinon mauvaise dimension(0) !)
      assert(v.size_array() == size_array() || get_info() == IntVect::info());
      copy_(v, opt);
    }
}

// Description: methode protegee appelable depuis une classe derivee
//  (pas de precondition sur le type derive de *this)
void IntVect::copy_(const IntVect& v, Array_base::Resize_Options opt)
{
  assert(&v != this); // Il faut avoir fait le test avant !
  // Si le vecteur a deja une structure parallele, la copie n'est autorisee que si
  // le vecteur source a la meme structure. Si ce n'est pas le cas, utiliser inject_array()
  // pour copier uniquement les valeurs, ou faire d'abord reset() si on veut ecraser la structure.
  assert((!md_vector_.non_nul()) || (md_vector_ == v.md_vector_));
  resize_array_(v.size_array(), NOCOPY_NOINIT);
  if (opt != NOCOPY_NOINIT)
    inject_array(v);
  md_vector_ = v.md_vector_; // Pour le cas ou md_vector_ est nul et pas v.md_vector_
  size_reelle_ = v.size_reelle_;
  line_size_ = v.line_size_;
}

// Description: idem que ArrOfInt::operator=(int)
IntVect& IntVect::operator=(int x)
{
  ArrOfInt::operator=(x);
  return *this;
}

// Description: methode virtuelle identique a resize_array(), permet de traiter
//   de facon generique les ArrOf, Vect et Tab.
//   Cree un tableau sequentiel...
//   Si l'objet est de type IntVect, appel a resize(n)
// Prerequis: voir resize()
void IntVect::resize_tab(int n, Array_base::Resize_Options opt)
{
  resize(n, opt);
}

// Description: voir ArrOfInt::ref_data().
//  (cree un tableau sans structure parallele)
void IntVect::ref_data(int* ptr, int new_size)
{
  md_vector_.detach();
  ArrOfInt::ref_data(ptr, new_size);
  size_reelle_ = new_size;
  line_size_ = 1;
}

// Description: voir ArrOfInt::ref_array().
//  (cree un tableau sans structure parallele)
void IntVect::ref_array(ArrOfInt& m, int start, int new_size)
{
  md_vector_.detach();
  ArrOfInt::ref_array(m, start, new_size);
  size_reelle_ = size_array(); // pas size qui peut valoir -1
  line_size_ = 1;
}

// Description: associe le md_vector au vecteur et initialise l'attribut size_reelle_
//  (voir methode size_reelle())
//  Si md_vector est nul, detache simplement le md_vector existant.
// Precondition: le vecteur doit deja avoir la taille appropriee au nouveau md_vector,
//  c'est a dire md_vector...get_nb_items_tot() * line_size_
void IntVect::set_md_vector(const MD_Vector& md_vector)
{
  int size_r = size_array();
  if (md_vector.non_nul())
    {
      size_r = md_vector.valeur().get_nb_items_reels();
      if (size_r >= 0)
        size_r *= line_size_;
      else
        size_r = -1; // Cas particulier ou la size_reelle ne veut rien dire
      int size_tot = md_vector.valeur().get_nb_items_tot() * line_size_;
      if (size_tot != size_array())
        {
          Cerr << "Internal error in IntVect::set_md_vector(): wrong array size\n"
               << " Needed size = " << md_vector.valeur().get_nb_items_tot() << " x " << line_size_
               << "\n Actual size = " << size_array() << finl;
          exit();
        }
      if (line_size_ == 0)
        {
          Cerr << "Internal error in IntVect::set_md_vector():\n"
               << " cannot attach descriptor to empty array (line_size_ is zero)" << finl;
          exit();
        }
    }
  size_reelle_ = size_r;
  md_vector_ = md_vector;
}

void IntVect::echange_espace_virtuel()
{
  MD_Vector_tools::echange_espace_virtuel(*this);
}

// Description: ecriture des valeurs du tableau "raw" sans structure parallele
void IntVect::ecrit(Sortie& os) const
{
  ArrOfInt::printOn(os);
  os << (int)-1 << finl; // le marqueur -1 indique que c'est le nouveau format "ecrit", sans structure parallele
}

void IntVect::jump(Entree& is)
{
  IntVect::lit(is, 0 /* Do not resize&read the array */);
}

// Description: lecture d'un tableau pour reprise de calcul. On lit les valeurs "raw".
//  Attention, si le tableau n'est pas vide, il doit deja avoir la bonne
//  taille et la bonne structure, sinon erreur !
// Parameter resize_and_read if the array is sized AND read (by default, yes)
void IntVect::lit(Entree& is, int resize_and_read)
{
  int sz = -1;
  is >> sz;
  if (resize_and_read)
    {
      if (size_array() == 0 && (!get_md_vector().non_nul()))
        {
          resize(sz, NOCOPY_NOINIT);
        }
      else
        {
          if (sz != size_array())
            {
              // Si on cherche a relire un tableau de taille inconnue, le tableau doit
              // etre reset() a l'entree. On n'aura pas la structure parallele du tableau !
              Cerr << "Error in IntVect::lit(Entree & is): array has already a structure with incorrect size" << finl;
              exit();
            }
        }
      is.get(addr(), sz);
    }
  else
    {
      // May be slow if large chunks are read:
      // Int tmp;
      //for (int i=0;i<sz;i++) is >> tmp;
      // So we bufferize:
      int buffer_size = min(sz,128000);
      ArrOfInt tmp(buffer_size);
      while(sz>buffer_size)
        {
          is.get(tmp.addr(), buffer_size);
          sz-=buffer_size;
        }
      is.get(tmp.addr(), sz);
    }
  int sz_reel = -2;
  is >> sz_reel;
  if (sz_reel >= 0)
    {
      // Lecture de l'ancien format. Ignore les valeurs lues.
      int sz_virt;
      is >> sz_virt;
      DescStructure toto;
      is >> toto;
    }
}

// Description:
//  renvoie 1 si meme strucuture parallele et egalite au sens ArrOfInt
//  (y compris espaces virtuels)
//  BM: faut-il etre aussi strict, comparer uniquement size() elements ?
int operator==(const IntVect& x, const IntVect& y)
{
  if (!(x.get_md_vector() == y.get_md_vector()))
    return 0;
  const ArrOfInt& ax = x;
  const ArrOfInt& ay = y;
  return ax == ay;
}

int operator!=(const IntVect& x, const IntVect& y)
{
  return !(x == y);
}



#ifndef NDEBUG
static void invalidate_data(IntVect& resu, Mp_vect_options opt)
{
  const int invalid = INT_MAX;
  const MD_Vector& md = resu.get_md_vector();
  const int line_size = resu.line_size();
  if (opt == VECT_ALL_ITEMS || (!md.non_nul()))
    return; // no invalid values
  assert(opt == VECT_SEQUENTIAL_ITEMS || opt == VECT_REAL_ITEMS);
  const ArrOfInt& items_blocs = (opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
  const int blocs_size = items_blocs.size_array();
  int i = 0;
  for (int blocs_idx = 0; blocs_idx < blocs_size; blocs_idx += 2)
    {
      // process data until beginning of next bloc, or end of array
      const int bloc_end = line_size * items_blocs[blocs_idx];
      int *ptr = resu.addr() + i;
      for (; i < bloc_end; i++)
        *(ptr++) = invalid;
      i = items_blocs[blocs_idx+1] * line_size;
    }
  // Process until end of vector
  const int bloc_end = resu.size_array();
  int *ptr = resu.addr() + i;
  for (; i < bloc_end; i++)
    *(ptr++) = invalid;
}
#endif




// Description:
//  Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur.
//  (tous les items si pas de structure parallele, sinon voir MD_Vector_base::get_items_to_sum()






int local_prodscal(const IntVect& vx, const IntVect& vy)
{
  int sum = 0;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  assert(vy.line_size() == line_size);
  assert(vy.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vy.get_md_vector() == md);
  // Determine blocs of data to process, depending on " VECT_SEQUENTIAL_ITEMS"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( VECT_SEQUENTIAL_ITEMS != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS ||  VECT_SEQUENTIAL_ITEMS == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  sum;
    }
  const int *x_base = vx.addr();
  const int *y_base = vy.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const int* x_ptr = x_base + begin_bloc;
      const int* y_ptr = y_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          const int y = *(y_ptr++);
          sum += x * y;
          x_ptr++;
        }
    }
  return  sum;
}
int local_carre_norme_vect(const IntVect& vx)
{
  int sum = 0;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " VECT_SEQUENTIAL_ITEMS"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( VECT_SEQUENTIAL_ITEMS != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS ||  VECT_SEQUENTIAL_ITEMS == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  sum;
    }
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          sum += x * x;
          x_ptr++;
        }
    }
  return  sum;
}
int mp_carre_norme_vect(const IntVect& vx)
{
  return Process::mp_sum(local_carre_norme_vect(vx));
}
int local_somme_vect(const IntVect& vx)
{
  int sum = 0;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " VECT_SEQUENTIAL_ITEMS"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( VECT_SEQUENTIAL_ITEMS != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS ||  VECT_SEQUENTIAL_ITEMS == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  sum;
    }
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          sum += x;
          x_ptr++;
        }
    }
  return  sum;
}
int mp_somme_vect(const IntVect& vx)
{
  int x = local_somme_vect(vx);
  int y = Process::mp_sum(x);
  return y;
}
int local_imin_vect(const IntVect& vx, Mp_vect_options opt)
{
  int min_val = INT_MAX;;
  int i_min = -1;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  i_min;
    }
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          if (x < min_val) { i_min = x_ptr - x_base; min_val = x; }
          x_ptr++;
        }
    }
  return  i_min;
}
int local_min_vect(const IntVect& vx, Mp_vect_options opt)
{
  int min_val = INT_MAX;;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  min_val;
    }
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          min_val = (x < min_val) ? x : min_val;
          x_ptr++;
        }
    }
  return  min_val;
}
int local_imax_vect(const IntVect& vx, Mp_vect_options opt)
{
  int max_val = INT_MIN;;
  int i_max = -1;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  i_max;
    }
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          if (x > max_val) { i_max = x_ptr - x_base; max_val = x; }
          x_ptr++;
        }
    }
  return  i_max;
}
int local_max_vect(const IntVect& vx, Mp_vect_options opt)
{
  int max_val = INT_MIN;;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  max_val;
    }
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          max_val = (x > max_val) ? x : max_val;
          x_ptr++;
        }
    }
  return  max_val;
}
int local_max_abs_vect(const IntVect& vx, Mp_vect_options opt)
{
  int max_val = 0;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  max_val;
    }
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          int xx = abs(x);
          max_val = (xx > max_val) ? xx : max_val;
          x_ptr++;
        }
    }
  return  max_val;
}
int local_min_abs_vect(const IntVect& vx, Mp_vect_options opt)
{
  int min_val = INT_MAX;;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  min_val;
    }
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          int xx = abs(x);
          min_val = (xx < min_val) ? xx : min_val;
          x_ptr++;
        }
    }
  return  min_val;
}
void operator_abs(IntVect& resu, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          int& p_resu = *(resu_ptr++);
          p_resu = abs(p_resu);
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_add(IntVect& resu, const IntVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          int& p_resu = *(resu_ptr++);
          p_resu += x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_add(IntVect& resu, const int x, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          int& p_resu = *(resu_ptr++);
          p_resu += x;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_sub(IntVect& resu, const IntVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          int& p_resu = *(resu_ptr++);
          p_resu -= x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_sub(IntVect& resu, const int x, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          int& p_resu = *(resu_ptr++);
          p_resu -= x;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_multiply(IntVect& resu, const IntVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          int& p_resu = *(resu_ptr++);
          p_resu *= x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_multiply(IntVect& resu, const int x, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          int& p_resu = *(resu_ptr++);
          p_resu *= x;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_negate(IntVect& resu, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          int& p_resu = *(resu_ptr++);
          p_resu = -p_resu;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_egal(IntVect& resu, int x, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          int& p_resu = *(resu_ptr++);
          p_resu = x;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_egal(IntVect& resu, const IntVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  const int *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      const int* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const int x = *x_ptr;
          int& p_resu = *(resu_ptr++);
          p_resu = x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_divide(IntVect& resu, const int x, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const IntVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  int *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      int* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          int& p_resu = *(resu_ptr++);
          if(x==0.) { Cerr << "Error: divide by 0 in operator_divide." << finl; Process::exit();};
          p_resu /= x;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}

int IntVect::local_min_vect(Mp_vect_options opt) const
{
  return ::local_min_vect(*this, opt);
}
int IntVect::local_max_vect(Mp_vect_options opt) const
{
  return ::local_max_vect(*this, opt);
}
int IntVect::local_max_abs_vect(Mp_vect_options opt) const
{
  return ::local_max_abs_vect(*this, opt);
}
int IntVect::local_min_abs_vect(Mp_vect_options opt) const
{
  return ::local_min_abs_vect(*this, opt);
}
int IntVect::mp_max_vect(Mp_vect_options opt) const
{
  return ::mp_max_vect(*this, opt);
}
int IntVect::mp_min_vect(Mp_vect_options opt) const
{
  return ::mp_min_vect(*this, opt);
}
int IntVect::mp_max_abs_vect(Mp_vect_options opt) const
{
  return ::mp_max_abs_vect(*this, opt);
}
int IntVect::mp_min_abs_vect(Mp_vect_options opt) const
{
  return ::mp_min_abs_vect(*this, opt);
}
void IntVect::operator+=(const IntVect& v)
{
  operator_add(*this, v);
}
void IntVect::operator-=(const IntVect& v)
{
  operator_sub(*this, v);
}
void IntVect::operator*=(const IntVect& v)
{
  operator_multiply(*this, v);
}
void IntVect::operator+=(const int x)
{
  operator_add(*this, x);
}
void IntVect::operator-=(const int x)
{
  operator_sub(*this, x);
}
void IntVect::operator*=(const int x)
{
  operator_multiply(*this, x);
}
int mp_max_vect(const IntVect& x, Mp_vect_options opt)
{
  int s = local_max_vect(x, opt);
  s =  mp_max(s);
  return s;
}
int mp_min_vect(const IntVect& x, Mp_vect_options opt)
{
  int s = local_min_vect(x, opt);
  s =  mp_min(s);
  return s;
}
int mp_max_abs_vect(const IntVect& x, Mp_vect_options opt)
{
  int s = local_max_abs_vect(x, opt);
  s = mp_max(s);
  return s;
}
int mp_min_abs_vect(const IntVect& x, Mp_vect_options opt)
{
  int s = local_min_abs_vect(x, opt);
  s = mp_min(s);
  return s;
}
int mp_prodscal(const IntVect& x, const IntVect& y)
{
  return Process::mp_sum(local_prodscal(x, y));
}




