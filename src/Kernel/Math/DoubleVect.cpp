/****************************************************************************
* Copyright (c) 2021, CEA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*****************************************************************************/
//////////////////////////////////////////////////////////////////////////////
//
// File:        DoubleVect.cpp
// Directory:   $TRUST_ROOT/src/Kernel/Math
// Version:     /main/v157_front_tracking/v157_ft_gbois/1
//
//////////////////////////////////////////////////////////////////////////////
//
// WARNING: DO NOT EDIT THIS FILE! Only edit the template file DoubleVect.cpp.P
//
//
#include <DoubleVect.h>
#include <math.h>
#ifdef SGI_
#include <bstring.h>
#endif
#include <MD_Vector_base.h>
#include <MD_Vector_tools.h>
#include <limits.h>
#include <communications.h>

// Pour la relecture des anciens fichiers de reprise, voir DoubleVect::lit()
#include <DescStructure.h>

Implemente_instanciable_sans_constructeur_ni_destructeur(DoubleVect, "DoubleVect", ArrOfDouble);

// Description: Ecriture d'un vecteur sequentiel (sans descripteur parallele)
//  Pour l'instant: erreur si presence d'un md_vector_ (sinon quoi faire ?)
//  Pour les vecteurs paralleles, utiliser une methode de sauvegarde/reprise
Sortie& DoubleVect::printOn(Sortie& os) const
{
  if (nproc() > 1 && md_vector_.non_nul())
    {
      Cerr << "Error in DoubleVect::printOn: try to print a parallel vector" << finl;
      exit();
    }
  ArrOfDouble::printOn(os);
  return os;
}

// Description: Lecture d'un vecteur sequentiel (comme un ArrOfDouble)
//  Attention: appel invalide si le vecteur a un MD_Vector non nul.
//  (pour les vecteurs paralleles, utiliser une methode de sauvegarde/reprise)
Entree& DoubleVect::readOn(Entree& is)
{
  if (md_vector_.non_nul())
    {
      // Que veut-on faire si on lit dans un vecteur ayant deja une structure parallele ?
      Cerr << "Error in DoubleVect::readOn: vector has a parallel structure" << finl;
      exit();
    }
  ArrOfDouble::readOn(is);
  size_reelle_ = size_array();
  line_size_ = 1;
  return is;
}

// Description: construction d'un vecteur de taille n.
//  Les elements du vecteur sont initialises a zero par defaut.
//  Pour ne pas initialiser les valeurs, utiliser ceci:
//   DoubleVect toto;
//   toto.resize(n, NOCOPY_NOINIT);
DoubleVect::DoubleVect(int n) :
  ArrOfDouble(n),
  size_reelle_(n),
  line_size_(1)
{
}
/*
// Description: construction d'un vecteur de taille n.
//  Les elements du vecteur sont initialises avec la valeur x.
DoubleVect::DoubleVect(int n, double x) :
  ArrOfDouble(n, x),
  size_reelle_(n),
  line_size_(1)
{
}
*/
// Description: Constructeur par copie. Il s'agit d'un "deep copy"
//   voir ArrOfDouble::ArrOfDouble(const ArrOfDouble &)
//  Remarque: il n'y a pas de constructeur par copie a partir de ArrOfDouble
//   Ceci est volontaire, sinon on risque de grosses pertes de performances
//   par creation implicite d'objets, difficile a trouver.
//   (exemple: appel d'une methode toto(const IntVect &) avec un ArrOfInt
//    produit une copie du tableau !)
//  Utiliser copy() pour copier un ArrOfDouble dans un DoubleVect
DoubleVect::DoubleVect(const DoubleVect& v) :
  ArrOfDouble(v),
  md_vector_(v.md_vector_),
  size_reelle_(v.size_reelle_),
  line_size_(v.line_size_)
{
}

// Description: met l'objet dans l'etat obtenu par le constructeur par defaut.
//  (voir ArrOfDouble::reset())
void DoubleVect::reset()
{
  md_vector_.detach();
  line_size_ = 1;
  size_reelle_ = 0;
  ArrOfDouble::reset();
}

// Description: detach the vector.
void DoubleVect::detach_vect()
{
  md_vector_.detach();
}

// Description: detache le tableau et l'attache a v (sauf si v==*this, ne fait rien)
//  Fait pointer le tableau sur la meme zone de memoire que v et copie le MD_Vector
//  (utilise ArrOfDouble::attach_array())
//  Attention, il devient alors interdit de resizer le tableau v ainsi que *this
//  Methode virtuelle reimplementee dans DoubleTab
// Precondition:
//  L'objet ne doit pas etre un sous-type de DoubleVect (sinon mauvaise initialisation
//  des dimensions.
void DoubleVect::ref(const DoubleVect& v)
{
  if (&v != this)
    {
      detach_array();
      attach_array(v);
      md_vector_ = v.md_vector_;
      size_reelle_ = v.size_reelle_;
      line_size_ = v.line_size_;
    }
}

// Description: copie la structure et les valeurs du tableau v dans *this avec ArrOfDouble::operator=()
//  (attention, si le tableau est de type ref_data ou ref, restrictions et cas particuliers !!!)
//  Attention: si on ne veut pas copier les structures paralleles, utiliser inject_array()
// Precondition: si le tableau *this doit etre resize, il doit etre de type DoubleVect
//  (et pas d'un type derive !)
//  Si le tableau *this a deja une structure parallele, l'appel n'est autorise que les md_vector
//  sont deja identiques, sinon il faut d'abord faire un reset() du tableau (pour copier la structure),
//  ou utiliser inject_array() (pour ne pas copier la structure).
//  (ceci pour eviter d'ecraser accidentellement une structure parallele alors qu'on ne veut
//   que copier les valeurs).
DoubleVect& DoubleVect::operator=(const DoubleVect& v)
{
  copy(v);
  return *this;
}

// Description: copie de la structure et des valeurs (si opt==COPY_INIT) du tableau v.
//  Attention, v doit vraiment etre de type ArrOfDouble, pas d'un type derive
//  (sinon ambiguite: faut-il copier ou pas le MD_Vector ?)
// Precondition: Le vecteur ne doit pas avoir de structure de tableau distribue
//  et il doit vraiment etre de type DoubleVect.
void DoubleVect::copy(const ArrOfDouble& v, Array_base::Resize_Options opt)
{
  assert(get_info() == DoubleVect::info());
  assert(v.get_info() == ArrOfDouble::info());
  assert(!md_vector_.non_nul());
  resize(v.size_array(), opt);
  if (opt != NOCOPY_NOINIT)
    inject_array(v);
}

// Description: copie de la structure du vecteur v et des valeurs si opt==COPY_INIT.
// Precondition: idem que operator=(const DoubleVect &)
void DoubleVect::copy(const DoubleVect& v, Array_base::Resize_Options opt)
{
  if (&v != this)
    {
      // Interdiction de resizer si l'objet est d'un type derive de DoubleVect
      // (sinon mauvaise dimension(0) !)
      assert(v.size_array() == size_array() || get_info() == DoubleVect::info());
      copy_(v, opt);
    }
}

// Description: methode protegee appelable depuis une classe derivee
//  (pas de precondition sur le type derive de *this)
void DoubleVect::copy_(const DoubleVect& v, Array_base::Resize_Options opt)
{
  assert(&v != this); // Il faut avoir fait le test avant !
  // Si le vecteur a deja une structure parallele, la copie n'est autorisee que si
  // le vecteur source a la meme structure. Si ce n'est pas le cas, utiliser inject_array()
  // pour copier uniquement les valeurs, ou faire d'abord reset() si on veut ecraser la structure.
  assert((!md_vector_.non_nul()) || (md_vector_ == v.md_vector_));
  resize_array_(v.size_array(), NOCOPY_NOINIT);
  if (opt != NOCOPY_NOINIT)
    inject_array(v);
  md_vector_ = v.md_vector_; // Pour le cas ou md_vector_ est nul et pas v.md_vector_
  size_reelle_ = v.size_reelle_;
  line_size_ = v.line_size_;
}

// Description: idem que ArrOfDouble::operator=(double)
DoubleVect& DoubleVect::operator=(double x)
{
  ArrOfDouble::operator=(x);
  return *this;
}

// Description: methode virtuelle identique a resize_array(), permet de traiter
//   de facon generique les ArrOf, Vect et Tab.
//   Cree un tableau sequentiel...
//   Si l'objet est de type DoubleVect, appel a resize(n)
// Prerequis: voir resize()
void DoubleVect::resize_tab(int n, Array_base::Resize_Options opt)
{
  resize(n, opt);
}

// Description: voir ArrOfDouble::ref_data().
//  (cree un tableau sans structure parallele)
void DoubleVect::ref_data(double* ptr, int new_size)
{
  md_vector_.detach();
  ArrOfDouble::ref_data(ptr, new_size);
  size_reelle_ = new_size;
  line_size_ = 1;
}

// Description: voir ArrOfDouble::ref_array().
//  (cree un tableau sans structure parallele)
void DoubleVect::ref_array(ArrOfDouble& m, int start, int new_size)
{
  md_vector_.detach();
  ArrOfDouble::ref_array(m, start, new_size);
  size_reelle_ = size_array(); // pas size qui peut valoir -1
  line_size_ = 1;
}

// Description: associe le md_vector au vecteur et initialise l'attribut size_reelle_
//  (voir methode size_reelle())
//  Si md_vector est nul, detache simplement le md_vector existant.
// Precondition: le vecteur doit deja avoir la taille appropriee au nouveau md_vector,
//  c'est a dire md_vector...get_nb_items_tot() * line_size_
void DoubleVect::set_md_vector(const MD_Vector& md_vector)
{
  int size_r = size_array();
  if (md_vector.non_nul())
    {
      size_r = md_vector.valeur().get_nb_items_reels();
      if (size_r >= 0)
        size_r *= line_size_;
      else
        size_r = -1; // Cas particulier ou la size_reelle ne veut rien dire
      int size_tot = md_vector.valeur().get_nb_items_tot() * line_size_;
      if (size_tot != size_array())
        {
          Cerr << "Internal error in DoubleVect::set_md_vector(): wrong array size\n"
               << " Needed size = " << md_vector.valeur().get_nb_items_tot() << " x " << line_size_
               << "\n Actual size = " << size_array() << finl;
          exit();
        }
      if (line_size_ == 0)
        {
          Cerr << "Internal error in DoubleVect::set_md_vector():\n"
               << " cannot attach descriptor to empty array (line_size_ is zero)" << finl;
          exit();
        }
    }
  size_reelle_ = size_r;
  md_vector_ = md_vector;
}

void DoubleVect::echange_espace_virtuel()
{
  MD_Vector_tools::echange_espace_virtuel(*this);
}

// Description: ecriture des valeurs du tableau "raw" sans structure parallele
void DoubleVect::ecrit(Sortie& os) const
{
  ArrOfDouble::printOn(os);
  os << (int)-1 << finl; // le marqueur -1 indique que c'est le nouveau format "ecrit", sans structure parallele
}

void DoubleVect::jump(Entree& is)
{
  DoubleVect::lit(is, 0 /* Do not resize&read the array */);
}

// Description: lecture d'un tableau pour reprise de calcul. On lit les valeurs "raw".
//  Attention, si le tableau n'est pas vide, il doit deja avoir la bonne
//  taille et la bonne structure, sinon erreur !
// Parameter resize_and_read if the array is sized AND read (by default, yes)
void DoubleVect::lit(Entree& is, int resize_and_read)
{
  int sz = -1;
  is >> sz;
  if (resize_and_read)
    {
      if (size_array() == 0 && (!get_md_vector().non_nul()))
        {
          resize(sz, NOCOPY_NOINIT);
        }
      else
        {
          if (sz != size_array())
            {
              // Si on cherche a relire un tableau de taille inconnue, le tableau doit
              // etre reset() a l'entree. On n'aura pas la structure parallele du tableau !
              Cerr << "Error in DoubleVect::lit(Entree & is): array has already a structure with incorrect size" << finl;
              exit();
            }
        }
      is.get(addr(), sz);
    }
  else
    {
      // May be slow if large chunks are read:
      // Double tmp;
      //for (int i=0;i<sz;i++) is >> tmp;
      // So we bufferize:
      int buffer_size = min(sz,128000);
      ArrOfDouble tmp(buffer_size);
      while(sz>buffer_size)
        {
          is.get(tmp.addr(), buffer_size);
          sz-=buffer_size;
        }
      is.get(tmp.addr(), sz);
    }
  int sz_reel = -2;
  is >> sz_reel;
  if (sz_reel >= 0)
    {
      // Lecture de l'ancien format. Ignore les valeurs lues.
      int sz_virt;
      is >> sz_virt;
      DescStructure toto;
      is >> toto;
      ArrOfInt it_communs;
      is >> it_communs;
      ArrOfInt it_communs_tot;
      is >> it_communs_tot;
    }
}

// Description:
//  renvoie 1 si meme strucuture parallele et egalite au sens ArrOfDouble
//  (y compris espaces virtuels)
//  BM: faut-il etre aussi strict, comparer uniquement size() elements ?
int operator==(const DoubleVect& x, const DoubleVect& y)
{
  if (!(x.get_md_vector() == y.get_md_vector()))
    return 0;
  const ArrOfDouble& ax = x;
  const ArrOfDouble& ay = y;
  return ax == ay;
}

int operator!=(const DoubleVect& x, const DoubleVect& y)
{
  return !(x == y);
}


#ifdef MICROSOFT
#define HUGE_VALL 1e99
#endif
// INVALID_SCALAR is used to fill arrays when values are not computed
// (virtual space might not be computed by operators).
// The value below probably triggers errors on parallel test cases but
// does not prevent from doing "useless" computations with it.

#ifndef NDEBUG
static void invalidate_data(DoubleVect& resu, Mp_vect_options opt)
{
  const double invalid = -987654.321;
  const MD_Vector& md = resu.get_md_vector();
  const int line_size = resu.line_size();
  if (opt == VECT_ALL_ITEMS || (!md.non_nul()))
    return; // no invalid values
  assert(opt == VECT_SEQUENTIAL_ITEMS || opt == VECT_REAL_ITEMS);
  const ArrOfInt& items_blocs = (opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
  const int blocs_size = items_blocs.size_array();
  int i = 0;
  for (int blocs_idx = 0; blocs_idx < blocs_size; blocs_idx += 2)
    {
      // process data until beginning of next bloc, or end of array
      const int bloc_end = line_size * items_blocs[blocs_idx];
      double *ptr = resu.addr() + i;
      for (; i < bloc_end; i++)
        *(ptr++) = invalid;
      i = items_blocs[blocs_idx+1] * line_size;
    }
  // Process until end of vector
  const int bloc_end = resu.size_array();
  double *ptr = resu.addr() + i;
  for (; i < bloc_end; i++)
    *(ptr++) = invalid;
}
#endif




// Description:
//  Renvoie la somme des x[i]*y[i] pour les items sequentiels sur ce processeur.
//  (tous les items si pas de structure parallele, sinon voir MD_Vector_base::get_items_to_sum()






double local_prodscal(const DoubleVect& vx, const DoubleVect& vy)
{
  double sum = 0;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  assert(vy.line_size() == line_size);
  assert(vy.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vy.get_md_vector() == md);
  // Determine blocs of data to process, depending on " VECT_SEQUENTIAL_ITEMS"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( VECT_SEQUENTIAL_ITEMS != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS ||  VECT_SEQUENTIAL_ITEMS == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  sum;
    }
  const double *x_base = vx.addr();
  const double *y_base = vy.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const double* x_ptr = x_base + begin_bloc;
      const double* y_ptr = y_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          const double y = *(y_ptr++);
          sum += x * y;
          x_ptr++;
        }
    }
  return  sum;
}
double local_carre_norme_vect(const DoubleVect& vx)
{
  double sum = 0;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " VECT_SEQUENTIAL_ITEMS"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( VECT_SEQUENTIAL_ITEMS != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS ||  VECT_SEQUENTIAL_ITEMS == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  sum;
    }
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          sum += x * x;
          x_ptr++;
        }
    }
  return  sum;
}
double mp_carre_norme_vect(const DoubleVect& vx)
{
  return Process::mp_sum(local_carre_norme_vect(vx));
}
double local_somme_vect(const DoubleVect& vx)
{
  double sum = 0;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " VECT_SEQUENTIAL_ITEMS"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( VECT_SEQUENTIAL_ITEMS != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS ||  VECT_SEQUENTIAL_ITEMS == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( VECT_SEQUENTIAL_ITEMS == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  sum;
    }
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          sum += x;
          x_ptr++;
        }
    }
  return  sum;
}
double mp_somme_vect(const DoubleVect& vx)
{
  double x = local_somme_vect(vx);
  double y = Process::mp_sum(x);
  return y;
}
int local_imin_vect(const DoubleVect& vx, Mp_vect_options opt)
{
  double min_val = HUGE_VALL;
  int i_min = -1;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  i_min;
    }
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          if (x < min_val) { i_min = x_ptr - x_base; min_val = x; }
          x_ptr++;
        }
    }
  return  i_min;
}
double local_min_vect(const DoubleVect& vx, Mp_vect_options opt)
{
  double min_val = HUGE_VALL;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  min_val;
    }
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          min_val = (x < min_val) ? x : min_val;
          x_ptr++;
        }
    }
  return  min_val;
}
int local_imax_vect(const DoubleVect& vx, Mp_vect_options opt)
{
  double max_val = (-HUGE_VALL);
  int i_max = -1;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  i_max;
    }
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          if (x > max_val) { i_max = x_ptr - x_base; max_val = x; }
          x_ptr++;
        }
    }
  return  i_max;
}
double local_max_vect(const DoubleVect& vx, Mp_vect_options opt)
{
  double max_val = (-HUGE_VALL);
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  max_val;
    }
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          max_val = (x > max_val) ? x : max_val;
          x_ptr++;
        }
    }
  return  max_val;
}
double local_max_abs_vect(const DoubleVect& vx, Mp_vect_options opt)
{
  double max_val = 0;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  max_val;
    }
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          double xx = fabs(x);
          max_val = (xx > max_val) ? xx : max_val;
          x_ptr++;
        }
    }
  return  max_val;
}
double local_min_abs_vect(const DoubleVect& vx, Mp_vect_options opt)
{
  double min_val = HUGE_VALL;
  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = vx;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return  min_val;
    }
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          double xx = fabs(x);
          min_val = (xx < min_val) ? xx : min_val;
          x_ptr++;
        }
    }
  return  min_val;
}
void operator_abs(DoubleVect& resu, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          double& p_resu = *(resu_ptr++);
          p_resu = fabs(p_resu);
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_add(DoubleVect& resu, const DoubleVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          double& p_resu = *(resu_ptr++);
          p_resu += x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_add(DoubleVect& resu, const double x, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          double& p_resu = *(resu_ptr++);
          p_resu += x;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_sub(DoubleVect& resu, const DoubleVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          double& p_resu = *(resu_ptr++);
          p_resu -= x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_sub(DoubleVect& resu, const double x, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          double& p_resu = *(resu_ptr++);
          p_resu -= x;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_multiply(DoubleVect& resu, const DoubleVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          double& p_resu = *(resu_ptr++);
          p_resu *= x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_multiply(DoubleVect& resu, const double x, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          double& p_resu = *(resu_ptr++);
          p_resu *= x;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_negate(DoubleVect& resu, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          double& p_resu = *(resu_ptr++);
          p_resu = -p_resu;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_egal(DoubleVect& resu, double x, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          double& p_resu = *(resu_ptr++);
          p_resu = x;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_egal(DoubleVect& resu, const DoubleVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          double& p_resu = *(resu_ptr++);
          p_resu = x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void ajoute_alpha_v(DoubleVect& resu, double alpha, const DoubleVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          double& p_resu = *(resu_ptr++);
          p_resu += alpha * x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void ajoute_carre(DoubleVect& resu, double alpha, const DoubleVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          double& p_resu = *(resu_ptr++);
          p_resu += alpha * x * x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void ajoute_produit_scalaire(DoubleVect& resu, double alpha, const DoubleVect& vx, const DoubleVect& vy, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  assert(vy.line_size() == line_size);
  assert(vy.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vy.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  const double *x_base = vx.addr();
  const double *y_base = vy.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      const double* x_ptr = x_base + begin_bloc;
      const double* y_ptr = y_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          const double y = *(y_ptr++);
          double& p_resu = *(resu_ptr++);
          p_resu += alpha * x * y;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void racine_carree(DoubleVect& resu, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          double& p_resu = *(resu_ptr++);
          p_resu = sqrt(p_resu);
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void carre(DoubleVect& resu, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          double& p_resu = *(resu_ptr++);
          p_resu *= p_resu;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_divide(DoubleVect& resu, const DoubleVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  assert(vx.line_size() == line_size);
  assert(vx.size_totale() == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          double& p_resu = *(resu_ptr++);
          if (x==0) { Cerr << "Divide by 0 in DoubleVect::operator_divide()" << finl; Process::exit();};
          p_resu /= x;
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
void operator_inverse(DoubleVect& resu, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          double& p_resu = *(resu_ptr++);
          if (p_resu==0) { Cerr << "Divide by 0 in DoubleVect::operateur_inverse()" << finl; Process::exit();};
          p_resu = 1. / p_resu;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
static void tab_multiply_any_shape_(DoubleVect& resu, const DoubleVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  int line_size_vx = vx.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Le line_size du vecteur resu doit etre un multiple du line_size du vecteur vx
  assert(line_size > 0 && line_size_vx > 0 && line_size % line_size_vx == 0);
  const int delta_line_size = line_size / line_size_vx;
  assert(vx.size_totale() * delta_line_size == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size_vx;
      const int end_bloc = (*(bloc_ptr++)) * line_size_vx;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc * delta_line_size;
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          // Any shape: pour chaque item de vx, on a delta_line_size items de resu a traiter
          for(int count2 = delta_line_size; count2; count2--)
            {
              double& p_resu = *(resu_ptr++);
              p_resu *= x;
            }
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
static void tab_divide_any_shape_(DoubleVect& resu, const DoubleVect& vx, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  int line_size_vx = vx.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Le line_size du vecteur resu doit etre un multiple du line_size du vecteur vx
  assert(line_size > 0 && line_size_vx > 0 && line_size % line_size_vx == 0);
  const int delta_line_size = line_size / line_size_vx;
  assert(vx.size_totale() * delta_line_size == vect_size_tot); // this test is necessary if md is null
  assert(vx.get_md_vector() == md);
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  const double *x_base = vx.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size_vx;
      const int end_bloc = (*(bloc_ptr++)) * line_size_vx;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc * delta_line_size;
      const double* x_ptr = x_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          const double x = *x_ptr;
          // Any shape: pour chaque item de vx, on a delta_line_size items de resu a traiter
          for(int count2 = delta_line_size; count2; count2--)
            {
              double& p_resu = *(resu_ptr++);
              if (x==0) { Cerr << "Divide by 0 in DoubleVect::tab_divide_any_shape_()" << finl; Process::exit();};
              p_resu *= (1. / x);
            }
          x_ptr++;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}
// Cette methode permettent de multiplier un tableau a plusieurs dimensions par un tableau
//  de dimension inferieure (par exemple un tableau a trois composantes par un tableau a une composante).
//  Chaque valeur du tableau vx est utilisee pour plusieurs items consecutifs du tableau resu
//  (le nombre de fois est le rapport des line_size() des deux tableaux).
//  resu.line_size() doit etre un multiple int de vx.line_size() et les descripteurs doivent etre identiques.
//  Cas particulier: vx peut contenir une constante unique (size_array() == 1 et descripteur nul),
//   dans ce cas c'est un simple produit par la constante
void tab_multiply_any_shape(DoubleVect& resu, const DoubleVect& vx, Mp_vect_options opt)
{
  if (vx.size_array() == 1 && !vx.get_md_vector().non_nul())
    {
      // Produit par une constante
      double x = vx[0];
      operator_multiply(resu, x, opt);
    }
  else if (vx.line_size() == resu.line_size())
    {
      // Produit membre a membre
      operator_multiply(resu, vx, opt);
    }
  else
    {
      // Cas general
      tab_multiply_any_shape_(resu, vx, opt);
    }
}
// Idem que tab_multiply_any_shape() mais avec une division
void tab_divide_any_shape(DoubleVect& resu, const DoubleVect& vx, Mp_vect_options opt)
{
  if (vx.size_array() == 1 && !vx.get_md_vector().non_nul())
    {
      // Produit par une constante
      if (vx[0]==0)
        {
          Cerr << "Divide by 0 in DoubleVect::tab_divide_any_shape()" << finl;
          Process::exit();
        }
      double x = 1. / vx[0];
      operator_multiply(resu, x, opt);
    }
  else if (vx.line_size() == resu.line_size())
    {
      // Produit membre a membre
      operator_divide(resu, vx, opt);
    }
  else
    {
      // Cas general
      tab_divide_any_shape_(resu, vx, opt);
    }
}
void operator_divide(DoubleVect& resu, const double x, Mp_vect_options opt)
{

  // Master vect donne la structure de reference, les autres vecteurs
  // doivent avoir la meme structure.
  const DoubleVect& master_vect = resu;
  int line_size = master_vect.line_size();
  const MD_Vector& md = master_vect.get_md_vector();
  const int vect_size_tot = master_vect.size_totale();
  // Determine blocs of data to process, depending on " opt"
  int nblocs_left = 1;
  int one_bloc[2];
  const int *bloc_ptr;
  if ( opt != VECT_ALL_ITEMS && md.non_nul())
    {
      assert( opt == VECT_SEQUENTIAL_ITEMS ||  opt == VECT_REAL_ITEMS);
      const ArrOfInt& items_blocs = ( opt == VECT_SEQUENTIAL_ITEMS) ? md.valeur().get_items_to_sum() : md.valeur().get_items_to_compute();
      assert(items_blocs.size_array() % 2 == 0);
      nblocs_left = items_blocs.size_array() >> 1;
      bloc_ptr = items_blocs.addr();
    }
  else if (vect_size_tot > 0)
    {
      // attention, si vect_size_tot est nul, line_size a le droit d'etre nul
      // Compute all data, in the vector (including virtual data), build a big bloc:
      nblocs_left = 1;
      bloc_ptr = one_bloc;
      one_bloc[0] = 0;
      one_bloc[1] = vect_size_tot / line_size;
    }
  else
    {
      // raccourci pour les tableaux vides (evite le cas particulier line_size == 0)
      return ;
    }
  double *resu_base = resu.addr();
  for (; nblocs_left; nblocs_left--)
    {
      // Get index of next bloc start:
      const int begin_bloc = (*(bloc_ptr++)) * line_size;
      const int end_bloc = (*(bloc_ptr++)) * line_size;
      assert(begin_bloc >= 0 && end_bloc <= vect_size_tot && end_bloc >= begin_bloc);
      double* resu_ptr = resu_base + begin_bloc;
      int count = end_bloc - begin_bloc;
      for (; count; count--)
        {
          double& p_resu = *(resu_ptr++);
          if(x==0.) { Cerr << "Error: divide by 0 in operator_divide." << finl; Process::exit();};
          p_resu /= x;
        }
    }
  // In debug mode, put invalid values where data has not been computed
#ifndef NDEBUG
  invalidate_data(resu,  opt);
#endif
  return ;
}

double DoubleVect::local_min_vect(Mp_vect_options opt) const
{
  return ::local_min_vect(*this, opt);
}
double DoubleVect::local_max_vect(Mp_vect_options opt) const
{
  return ::local_max_vect(*this, opt);
}
double DoubleVect::local_max_abs_vect(Mp_vect_options opt) const
{
  return ::local_max_abs_vect(*this, opt);
}
double DoubleVect::local_min_abs_vect(Mp_vect_options opt) const
{
  return ::local_min_abs_vect(*this, opt);
}
double DoubleVect::mp_max_vect(Mp_vect_options opt) const
{
  return ::mp_max_vect(*this, opt);
}
double DoubleVect::mp_min_vect(Mp_vect_options opt) const
{
  return ::mp_min_vect(*this, opt);
}
double DoubleVect::mp_max_abs_vect(Mp_vect_options opt) const
{
  return ::mp_max_abs_vect(*this, opt);
}
double DoubleVect::mp_min_abs_vect(Mp_vect_options opt) const
{
  return ::mp_min_abs_vect(*this, opt);
}
void DoubleVect::operator+=(const DoubleVect& v)
{
  operator_add(*this, v);
}
void DoubleVect::operator-=(const DoubleVect& v)
{
  operator_sub(*this, v);
}
void DoubleVect::operator*=(const DoubleVect& v)
{
  operator_multiply(*this, v);
}
void DoubleVect::operator+=(const double x)
{
  operator_add(*this, x);
}
void DoubleVect::operator-=(const double x)
{
  operator_sub(*this, x);
}
void DoubleVect::operator*=(const double x)
{
  operator_multiply(*this, x);
}
double mp_max_vect(const DoubleVect& x, Mp_vect_options opt)
{
  double s = local_max_vect(x, opt);
  s =  Process::mp_max(s);
  return s;
}
double mp_min_vect(const DoubleVect& x, Mp_vect_options opt)
{
  double s = local_min_vect(x, opt);
  s =  Process::mp_min(s);
  return s;
}
double mp_max_abs_vect(const DoubleVect& x, Mp_vect_options opt)
{
  double s = local_max_abs_vect(x, opt);
  s = Process::mp_max(s);
  return s;
}
double mp_min_abs_vect(const DoubleVect& x, Mp_vect_options opt)
{
  double s = local_min_abs_vect(x, opt);
  s = Process::mp_min(s);
  return s;
}
void DoubleVect::operator/=(const double x)
{
  operator_divide(*this, x);
}
void DoubleVect::operator/=(const DoubleVect& v)
{
  operator_divide(*this, v);
}
void DoubleVect::abs(Mp_vect_options opt)
{
  operator_abs(*this, opt);
}
void DoubleVect::carre(Mp_vect_options opt)
{
  ::carre(*this, opt);
}
void DoubleVect::racine_carree(Mp_vect_options opt)
{
  ::racine_carree(*this, opt);
}
void DoubleVect::ajoute(double alpha, const DoubleVect& y, Mp_vect_options opt)
{
  ajoute_alpha_v(*this, alpha, y, opt);
  if (opt == VECT_ALL_ITEMS)
    echange_espace_virtuel();
}
void DoubleVect::ajoute_sans_ech_esp_virt(double alpha, const DoubleVect& y, Mp_vect_options opt)
{
  ajoute_alpha_v(*this, alpha, y, opt);
}
void DoubleVect::ajoute_produit_scalaire(double alpha, const DoubleVect& x, const DoubleVect& y, Mp_vect_options opt)
{
  ::ajoute_produit_scalaire(*this, alpha, x, y, opt);
}
void DoubleVect::ajoute_carre(double alpha, const DoubleVect& y, Mp_vect_options opt)
{
  ::ajoute_carre(*this, alpha, y, opt);
}
double mp_moyenne_vect(const DoubleVect& x)
{
  double s = mp_somme_vect(x);
  double n;
  const MD_Vector& md = x.get_md_vector();
  if (md.non_nul())
    n = md.valeur().nb_items_seq_tot() * x.line_size();
  else
    {
      // Coding error: mp_moyenne_vect is used on a not distributed DoubleVect !
      assert(Process::nproc()==1);
      n = x.size_totale();
    }
  return s / n;
}
double mp_prodscal(const DoubleVect& x, const DoubleVect& y)
{
  return Process::mp_sum(local_prodscal(x, y));
}



double DoubleVect::mp_norme_vect() const
{
  return ::mp_norme_vect(*this);
}
double mp_norme_vect(const DoubleVect& vx)
{
  double x = mp_carre_norme_vect(vx);
  x = sqrt(x);
  return x;
}


