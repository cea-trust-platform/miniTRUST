/****************************************************************************
* Copyright (c) 2021, CEA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*****************************************************************************/
//////////////////////////////////////////////////////////////////////////////
//
// File:        IntTab.cpp
// Directory:   $TRUST_ROOT/src/Kernel/Math
// Version:     /main/10
//
//////////////////////////////////////////////////////////////////////////////
//
// WARNING: DO NOT EDIT THIS FILE! Only edit the template file IntTab.cpp.P
//
//
#include <IntTab.h>
#include <MD_Vector_base.h>
#include <Ref_IntTab.h>
#include <Vect_IntTab.h>

Implemente_instanciable_sans_constructeur(IntTab, "IntTab",IntVect);
Implemente_ref(IntTab);
Implemente_vect(IntTab);

// Verifie la coherence entre size_array(), line_size() et les dimensions du tableau
#if MAXDIM_TAB != 4
#error Mettre a jour le code pour MAXDIM_TAB pour CHECK_LINE_SIZE
#endif
#define CHECK_LINE_SIZE                                                        \
  ((line_size() == ((nb_dim_>1)?dimensions_[1]:1)*((nb_dim_>2)?dimensions_[2]:1)*((nb_dim_>3)?dimensions_[3]:1)) \
   && (line_size() * dimension_tot_0_ == size_array()))

// Description: ecriture d'un tableau sequentiel
//  (idem que IntVect::printOn() on ne sait pas quoi faire de pertinent
//   pour un tableau distribue).
Sortie& IntTab::printOn(Sortie& os) const
{
  assert(CHECK_LINE_SIZE);
  if (nproc() > 1 && get_md_vector().non_nul())
    {
      Cerr << "Error in IntTab::printOn: try to print a parallel vector" << finl;
      exit();
    }
  os << nb_dim_ << finl;
  assert(dimensions_[0] == dimension_tot_0_);
  if (nb_dim_ > 0)
    os.put(dimensions_, nb_dim_, nb_dim_);

  const int sz = size_array();
  os << sz << finl;
  const int l_size = line_size();
  const int *data = addr();
  if (sz > 0)
    os.put(data, sz, l_size);
  return os;
}

// Description: lecture d'un tableau sequentiel
// Precondition: le md_vector_ doit etre nul.
Entree& IntTab::readOn(Entree& is)
{
  if (get_md_vector().non_nul())
    {
      // Que veut-on faire si on lit dans un vecteur ayant deja une structure parallele ?
      Cerr << "Error in IntTab::readOn: vector has a parallel structure" << finl;
      exit();
    }

  is >> nb_dim_;
  if (nb_dim_ < 1 || nb_dim_ > MAXDIM_TAB)
    {
      Cerr << "Error in IntTab::readOn: wrong nb_dim_ = " << nb_dim_ << finl;
      exit();
    }
  is.get(dimensions_, nb_dim_);
  if (dimensions_[0] < 0)
    {
      Cerr << "Error in IntTab::readOn: wrong dimension(0) = " << dimensions_[0] << finl;
      exit();
    }
  int l_size = 1;
  for (int i = 1; i < nb_dim_; i++)
    {
      if (dimensions_[i] < 0)
        {
          Cerr << "Error in IntTab::readOn: wrong dimension(" << i << ") = " << dimensions_[i] << finl;
          exit();
        }
      l_size *= dimensions_[i];
    }
  dimension_tot_0_ = dimensions_[0];
  IntVect::readOn(is);
  set_line_size_(l_size);
  if (dimension_tot_0_ * l_size != size_array())
    {
      Cerr << "Error in IntTab::readOn: wrong size_array " << size_array()
           << ", expected " << dimension_tot_0_ * l_size << finl;
      exit();
    }
  assert(CHECK_LINE_SIZE);
  return is;
}

static inline void init_dimensions(int * tab)
{
#ifndef NDEBUG
  for (int i = 0; i < MAXDIM_TAB; i++)
    tab[i] = -1;
#endif
}

IntTab::IntTab() :
  nb_dim_(1), dimension_tot_0_(0)
{
  init_dimensions(dimensions_);
  dimensions_[0] = 0;
}

IntTab::IntTab(const IntTab& dbt) :
  IntVect(dbt),
  nb_dim_(dbt.nb_dim_),
  dimension_tot_0_(dbt.dimension_tot_0_)
{
  for (int i = 0; i < MAXDIM_TAB; i++)
    dimensions_[i] = dbt.dimensions_[i];
}
#define PARAM_X
#define PARAM_X2

IntTab::IntTab(int n PARAM_X)
  : IntVect(n PARAM_X2),
    nb_dim_(1),
    dimension_tot_0_(n)
{
  init_dimensions(dimensions_);
  dimensions_[0] = n;
}

IntTab::IntTab(int n1, int n2 PARAM_X)
  : IntVect(n1*n2 PARAM_X2),
    nb_dim_(2),
    dimension_tot_0_(n1)
{
  assert(n1 >= 0 && n2 >= 0);
  if (n1*n2<0)
    {
      Cerr << "n1*n2 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n1 << " and n2=" << n2 << finl;
      exit();
    }
  init_dimensions(dimensions_);
  dimensions_[0]=n1;
  dimensions_[1]=n2;
  set_line_size_(n2);
}
#ifdef INT_is_64_
IntTab::IntTab(int n1, True_int n2 PARAM_X)
  : IntVect(n1*n2 PARAM_X2),
    nb_dim_(2),
    dimension_tot_0_(n1)
{
  assert(n1 >= 0 && n2 >= 0);
  if (n1*n2<0)
    {
      Cerr << "n1*n2 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n1 << " and n2=" <<(int) n2 << finl;
      exit();
    }
  init_dimensions(dimensions_);
  dimensions_[0]=n1;
  dimensions_[1]=n2;
  set_line_size_(n2);
}
#endif

IntTab::IntTab(int n1, int n2, int n3 PARAM_X)
  : IntVect(n1*n2*n3 PARAM_X2),
    nb_dim_(3),
    dimension_tot_0_(n1)
{
  assert(n1 >= 0 && n2 >= 0 && n3 >= 0);
  if (n1*n2*n3<0)
    {
      Cerr << "n1*n2*n3 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n1 << " and n2=" << n2 << " and n3=" << n3 << finl;
      exit();
    }
  init_dimensions(dimensions_);
  dimensions_[0]=n1;
  dimensions_[1]=n2;
  dimensions_[2]=n3;
  set_line_size_(n2*n3);
}

IntTab::IntTab(int n1, int n2, int n3, int n4 PARAM_X)
  : IntVect(n1*n2*n3*n4 PARAM_X2),
    nb_dim_(4),
    dimension_tot_0_(n1)
{
  assert(n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 >= 0);
  if (n1*n2*n3*n4<0)
    {
      Cerr << "n1*n2*n3*n4 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n1 << " and n2=" << n2 << " and n3=" << n3 << " and n3=" << n3 << finl;
      exit();
    }
  init_dimensions(dimensions_);
  dimensions_[0]=n1;
  dimensions_[1]=n2;
  dimensions_[2]=n3;
  dimensions_[3]=n4;
  set_line_size_(n2*n3*n4);
}

// Description: fait pointer le tableau sur le vecteur v et en associant
//  la meme structure parallele.
//  Attention, si line_size du vecteur v est different de 1,
//  on cree un tableau bidimensionnel (on peut avoir un vecteur
//  de ce type si on copie un Tab dans un Vect puis on prend
//  une ref sur ce Vect).
// Precondition: le vecteur v doit vraiment etre de type Vect !
//   (sinon utiliser IntTab::ref(const IntTab &)
void IntTab::ref(const IntVect& v)
{
  assert(v.get_info() == IntVect::info());
  IntVect::ref(v);
  const int l = v.line_size();
  // Attention:
  //  En prenant la ref, on est oblige de conserver l'attribut line_size
  //  du Vect (sinon echange_espace_virtuel ne fonctionnera pas car
  //  on n'aura pas le bon facteur multiplicatif des items geometriques)
  //  Si on voulait creer un tableau monodimensionnel avec line_size > 1,
  //  le tableau devient invalide car on n'a plus line_size = produit des
  //  dimensions > 1.
  //  On peut le faire a condition de laisser tomber le md_vector_ en
  //  faisant  tab.ref_array(v) au lieu de  tab.ref(v)
  if (l == 1)
    {
      nb_dim_ = 1;
    }
  else
    {
      nb_dim_ = 2;
      dimensions_[1] = l;
    }
  if (v.size_reelle_ok())
    {
      int sz = v.size_reelle();
      dimensions_[0] = sz / l;
    }
  else
    {
      dimensions_[0] = -1;
    }
  dimension_tot_0_ = size_array() / l;
  assert(CHECK_LINE_SIZE);
}

// Description: fait pointer le tableau sur le tableau t
//  en recuperant la structure parallele. Attention,
//  on fige le tableau qui ne pourra plus etre resize
void IntTab::ref(const IntTab& src)
{
  IntVect::ref(src);
  nb_dim_ = src.nb_dim_;
  for (int i = 0; i < MAXDIM_TAB; i++)
    dimensions_[i] = src.dimensions_[i];
  dimension_tot_0_ = src.dimension_tot_0_;
  assert(CHECK_LINE_SIZE);
}

// Description: identique a DoubleVect::ref_data()
void IntTab::ref_data(int* ptr, int new_size)
{
  IntVect::ref_data(ptr, new_size);
  assert(!get_md_vector().non_nul() && size_reelle() == size_array());
  nb_dim_ = 1;
  dimensions_[0] = dimension_tot_0_ = new_size;
  assert(CHECK_LINE_SIZE);
}

// Description: identique a DoubleVect::ref_array()
//  (cree un tableau monodimensionnel sans structure parallele)
//  Attention, le tableau source et destination sont figes (resize interdit)
//  (voir ArrOfInt::
void IntTab::ref_array(ArrOfInt& src, int start, int sz)
{
  IntVect::ref_array(src, start, sz);
  assert(!get_md_vector().non_nul() && size_reelle() == size_array());
  nb_dim_ = 1;
  dimensions_[0] = dimension_tot_0_ = size_array(); // pas sz qui peut valoir -1
  assert(CHECK_LINE_SIZE);
}

// Description: fait pointer le tableau sur une sous-partie du tableau t
//   definie par la valeur du premier indice et ne nombre de "lignes" du tableau
//   a recuperer (une ligne = toutes les valeurs tab(i,j,k,...) pour un i donne).
//   Le nombre de dimensions du tableau est le meme que pour t,
//   les dimension(i) pour i>=1 sont les memes et dimension(0) = nb_lines.
void IntTab::ref_tab(IntTab& t, int start_line, int nb_lines)
{
  if (nb_lines < 0)
    nb_lines = t.dimension_tot_0_ - start_line;
  assert(start_line >= 0 && nb_lines >= 0 && start_line + nb_lines <= t.dimension_tot_0_);
  const int l_size = t.line_size();
  IntVect::ref_array(t, start_line * l_size, nb_lines * l_size);
  assert(!get_md_vector().non_nul() && size_reelle() == size_array());
  set_line_size_(l_size);
  nb_dim_ = t.nb_dim_;
  dimension_tot_0_ = nb_lines;
  dimensions_[0] = nb_lines;
  for (int i = 1; i < MAXDIM_TAB; i++)
    dimensions_[i] = t.dimensions_[i];
  assert(CHECK_LINE_SIZE);
}

// Description: met le tableau dans l'etat obtenu par le constructeur par defaut
//  voir IntVect::reset()
void IntTab::reset()
{
  nb_dim_ = 1;
  dimensions_[0] = 0;
  dimension_tot_0_ = 0;
  IntVect::reset();
  assert(CHECK_LINE_SIZE);
}

// Description: methode virtuelle qui force le tableau a changer de taille.
//  Change aussi nb_dim_ a 1. Equivalent a IntTab::resize(n, opt)
void IntTab::resize_tab(int n, Array_base::Resize_Options opt)
{
  resize(n, opt);
  assert(CHECK_LINE_SIZE);
}

// Description: change la dimension[0] du tableau en conservant les autres.
// Precondition: le tableau ne doit pas avoir de structure parallele
void IntTab::resize_dim0(int n, Array_base::Resize_Options opt)
{
  assert(n >= 0);
  assert(dimension_tot_0_ * line_size() == size_array());
  IntVect::resize_vect_(n * line_size(), opt);
  dimensions_[0] = dimension_tot_0_ = n;
  assert(CHECK_LINE_SIZE);
}

void IntTab::resize(int n, Array_base::Resize_Options opt)
{
  assert(n >= 0);
  set_line_size_(1);
  IntVect::resize_vect_(n, opt);
  nb_dim_ = 1;
  dimensions_[0] = dimension_tot_0_ = n;
  assert(CHECK_LINE_SIZE);
}

void IntTab::resize(int n, int n2, Array_base::Resize_Options opt)
{
  assert(n >= 0 && n2 >= 0);
  set_line_size_(n2);
  int new_size = n * n2;
  if (new_size<0)
    {
      Cerr << "n1*n2 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n << " and n2=" << n2 << finl;
      exit();
    }

  IntVect::resize_vect_(new_size, opt);
  nb_dim_ = 2;
  dimensions_[0] = dimension_tot_0_ = n;
  dimensions_[1] = n2;
  assert(CHECK_LINE_SIZE);
}

void IntTab::resize(int n, int n2, int n3, Array_base::Resize_Options opt)
{
  assert(n >= 0 && n2 >= 0 && n3 >= 0);
  set_line_size_(n2 * n3);
  int new_size = n * n2 * n3;
  if (new_size<0)
    {
      Cerr << "n1*n2*n3 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n << " and n2=" << n2 << " and n3=" << n3 << finl;
      exit();
    }

  IntVect::resize_vect_(new_size, opt);
  nb_dim_ = 3;
  dimensions_[0] = dimension_tot_0_ = n;
  dimensions_[1] = n2;
  dimensions_[2] = n3;
  assert(CHECK_LINE_SIZE);
}

void IntTab::resize(int n, int n2, int n3, int n4, Array_base::Resize_Options opt)
{
  assert(n >= 0 && n2 >= 0 && n3 >= 0 && n4 >= 0);
  set_line_size_(n2 * n3 * n4);
  int new_size = n * n2 * n3 * n4;
  if (new_size<0)
    {
      Cerr << "n1*n2*n3*n4 > 2^31. Error! Contact TRUST support, integer 32 bits limit exceeded with n1=" << n << " and n2=" << n2 << " and n3=" << n3 << " and n4=" << n4 << finl;
      exit();
    }

  IntVect::resize_vect_(new_size, opt);
  nb_dim_ = 4;
  dimensions_[0] = dimension_tot_0_ = n;
  dimensions_[1] = n2;
  dimensions_[2] = n3;
  dimensions_[3] = n4;
  assert(CHECK_LINE_SIZE);
}

// Description: redimensionne le tableau (nb_dim_ sera egal a tailles.size_array()
//   et dimension(i) a tailles[i].
// Precondition: identiques a IntVect::resize_vect_()
void IntTab::resize(const ArrOfInt& tailles, Array_base::Resize_Options opt)
{
  nb_dim_ = tailles.size_array();
  if (nb_dim_ <= 0 || nb_dim_ > MAXDIM_TAB)
    {
      Cerr << "Internal error in IntTab::resize(const ArrOfInt & tailles, ...) \n"
           << " wrong dimensions number " << nb_dim_ << finl;
      exit();
    }
  int l_size = 1;
  for (int i = 0; i < nb_dim_; i++)
    {
      const int n = tailles[i];
      dimensions_[i] = n;
      if (i > 0)
        l_size *= n;
      if (n < 0)
        {
          Cerr << "Internal error in IntTab::resize(const ArrOfInt & tailles, ...) \n"
               << " wrong dimensions: " << tailles << finl;
          exit();
        }
    }
  dimension_tot_0_ = dimensions_[0];
  set_line_size_(l_size);
  resize_vect_(dimensions_[0] * l_size, opt);
  assert(CHECK_LINE_SIZE);
}

// Description: copie la structure et les valeurs du tableau src
//   Restrictions et preconditions identiques a IntVect::operator=(const IntVect & v)
IntTab& IntTab::operator=(const IntTab& src)
{
  copy(src);
  return *this;
}

// Description: copie la structure et les valeurs de src.
//  Attention: appel invalide si src est un type derive de Vect
//  (sinon quoi faire, un tableau unidimensionnel, ou une copie de la structure ?)
IntTab& IntTab::operator=(const IntVect& src)
{
  assert(src.get_info() == IntVect::info());
  IntVect::copy_(src);
  // Idem que dans ref(IntVect) pour le nombre de dimensions du tableau cree
  const int l = src.line_size();
  if (l == 1)
    {
      nb_dim_ = 1;
    }
  else
    {
      nb_dim_ = 2;
      dimensions_[1] = l;
    }
  if (src.size_reelle_ok())
    {
      int sz = src.size_reelle();
      dimensions_[0] = sz / l;
      assert(sz % l == 0);
    }
  else
    {
      dimensions_[0] = -1;
    }
  dimension_tot_0_ = size_array() / l;
  assert(CHECK_LINE_SIZE);
  return *this;
}

IntTab& IntTab::operator=(int d)
{
  IntVect::operator=(d);
  return *this;
}

void IntTab::copy(const IntTab& src, Array_base::Resize_Options opt)
{
  if (&src != this)
    {
      IntVect::copy_(src, opt);
      nb_dim_ = src.nb_dim_;
      for (int i = 0; i < MAXDIM_TAB; i++)
        dimensions_[i] = src.dimensions_[i];
      dimension_tot_0_ = src.dimension_tot_0_;
      assert(CHECK_LINE_SIZE);
    }
}

int& IntTab::operator()(const ArrOfInt& indice)
{
  assert(indice.size_array() == nb_dim_);
#if MAXDIM_TAB != 4
#error Mettre a jour le code pour MAXDIM_TAB ici
#endif
  switch(nb_dim_)
    {
    case 1:
      return operator()(indice[0]);
    case 2:
      return operator()(indice[0], indice[1]);
    case 3:
      return operator()(indice[0], indice[1], indice[2]);
    default:
      return operator()(indice[0], indice[1], indice[2], indice[3]);
    }
}
int IntTab::operator()(const ArrOfInt& indice) const
{
  assert(indice.size_array() == nb_dim_);
#if MAXDIM_TAB != 4
#error Mettre a jour le code pour MAXDIM_TAB ici
#endif
  switch(nb_dim_)
    {
    case 1:
      return operator()(indice[0]);
    case 2:
      return operator()(indice[0], indice[1]);
    case 3:
      return operator()(indice[0], indice[1], indice[2]);
    default:
      return operator()(indice[0], indice[1], indice[2], indice[3]);
    }
}

// Description: associe le md_vector au vecteur (voir IntVect::set_md_vector())
//  dimension(0) sera initialise a md_vector...get_nb_items_reels().
// Precondition: en plus des preconditions de IntVect::set_md_vector(),
//  dimension_tot(0) doit etre egal a get_nb_items_tot() du md_vector.
void IntTab::set_md_vector(const MD_Vector& md_vector)
{
  int dim0 = dimension_tot_0_;
  if (md_vector.non_nul())
    {
      // renvoie -1 si l'appel et invalide:
      dim0 = md_vector.valeur().get_nb_items_reels();
    }
  dimensions_[0] = dim0;
  assert(CHECK_LINE_SIZE);
  // a appeler meme pour un md_vector nul (pour remettre size_reelle_):
  IntVect::set_md_vector(md_vector);
}

void IntTab::ecrit(Sortie& os) const
{
  os << nb_dim_ << finl;
  if (nb_dim_ > 0)
    os.put(dimensions_, nb_dim_, nb_dim_);
  ArrOfInt tmp(nb_dim_);
  for (int i = 0; i < nb_dim_; i++)
    tmp[i] = dimension_tot(i);
  os << tmp;
  IntVect::ecrit(os);
}

void IntTab::jump(Entree& is)
{
  IntTab::lit(is, 0 /* Do not resize&read the array */);
}

// Description: lecture d'un tableau pour reprise de calcul. On lit les valeurs "raw".
//  Attention, si le tableau n'est pas vide, il doit deja avoir la bonne
//  taille et la bonne structure, sinon erreur !
// Parameter resize_and_read if the array is sized AND read (by default, yes)
void IntTab::lit(Entree& is, int resize_and_read)
{
  ArrOfInt tmp;
  is >> tmp;
  int ok = 1;
  if (tmp.size_array() != nb_dim_)
    ok = 0;
  if (ok)
    {
      if (size_reelle_ok() && dimension(0) != tmp[0])
        ok = 0;
      for (int i = 1; i < nb_dim_; i++)
        if (dimension(i) != tmp[i])
          ok = 0;
    }
  is >> tmp;
  if (ok && tmp.size_array() != nb_dim_)
    ok = 0;
  if (ok)
    for (int i = 0; i < nb_dim_; i++)
      if (dimension_tot(i) != tmp[i])
        ok = 0;
  // Autorisation ancien format des champs scalaire 183:
  if (tmp.size_array()==1 && nb_dim_==2 && dimension(1)==1 && dimension_tot(0) == tmp[0])
    ok = 1;
  if (resize_and_read)
    {
      if (size_array() == 0 && (!get_md_vector().non_nul()))
        {
          resize(tmp, NOCOPY_NOINIT);
        }
      else
        {
          if (!ok)
            {
              // Si on cherche a relire un tableau de taille inconnue, le tableau doit
              // etre reset() a l'entree. On n'aura pas la structure parallele du tableau !
              Cerr << "Error in IntTab::lit: array has wrong dimensions" << finl;
              exit();
            }
        }
    }
  IntVect::lit(is,resize_and_read);
}


